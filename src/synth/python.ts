// SPIRAL Python Synthesizer
// Translates SPIRAL documents (AIR/CIR/EIR/LIR) to executable Python code

import type {
	AIRDef, AIRDocument, CIRDocument, EIRDocument,
	Expr, EirExpr, Node, EirNode,
	LIRDocument,
	LirHybridNode,
	Value,
} from "../types.js";
import { isBlockNode, isExprNode } from "../types.js";

//==============================================================================
// Options and Types
//==============================================================================

export interface PythonSynthOptions {
	/** Module name for generated code (used in comments) */
	moduleName?: string;
	/** Include type hints in generated Python */
	typeHints?: boolean;
	/** Include debug comments */
	debugComments?: boolean;
}

type Document = AIRDocument | CIRDocument | EIRDocument | LIRDocument;

//==============================================================================
// Operator Mappings
//==============================================================================

interface OperatorMapping {
	pythonOp: string;
	customImpl?: (args: string[]) => string;
}

const OPERATOR_MAP: Record<string, OperatorMapping> = {
	"core:add": { pythonOp: "+" },
	"core:sub": { pythonOp: "-" },
	"core:mul": { pythonOp: "*" },
	"core:div": { pythonOp: "//", customImpl: (args) => `int(${args[0]} // ${args[1]})` },
	"core:mod": { pythonOp: "%" },
	"core:pow": { pythonOp: "**" },
	"core:neg": { pythonOp: "-", customImpl: (args) => `(-${args[0]})` },
	"core:eq": { pythonOp: "==" },
	"core:neq": { pythonOp: "!=" },
	"core:lt": { pythonOp: "<" },
	"core:lte": { pythonOp: "<=" },
	"core:gt": { pythonOp: ">" },
	"core:gte": { pythonOp: ">=" },
	"bool:and": { pythonOp: "and" },
	"bool:or": { pythonOp: "or" },
	"bool:not": { pythonOp: "not", customImpl: (args) => `(not ${args[0]})` },
	"list:length": { pythonOp: "len", customImpl: (args) => `len(${args[0]})` },
	"list:concat": { pythonOp: "+", customImpl: (args) => `(${args[0]} + ${args[1]})` },
};

/**
 * Type guard: checks whether a Document is a LIR document
 * by verifying it has nodes with block structure.
 */
function isLIRDocument(doc: Document): doc is LIRDocument {
	return "nodes" in doc && doc.nodes.some((n) => "blocks" in n && "entry" in n);
}

/**
 * Type guard: checks whether a Document is an expression-based document (AIR/CIR/EIR).
 */
function isExprBasedDocument(doc: Document): doc is AIRDocument | CIRDocument | EIRDocument {
	return "nodes" in doc && "airDefs" in doc && Array.isArray(doc.airDefs);
}

/**
 * Main entry point for Python synthesis
 */
export function synthesizePython(doc: Document, opts: PythonSynthOptions = {}): string {
	const { moduleName = "spiral_generated" } = opts;

	// Detect IR layer and dispatch
	// LIR documents have nodes containing block nodes (CFG-based)
	// Check if any node has blocks/entry (block node structure)
	if (isLIRDocument(doc)) {
		return synthesizeLIR(doc, { moduleName });
	}
	// Expression-based documents (AIR/CIR/EIR) with nodes
	if (isExprBasedDocument(doc)) {
		return synthesizeExprBased(doc, { moduleName });
	}

	throw new Error("Unrecognized document format");
}

//==============================================================================
// Expression-Based Synthesis (AIR/CIR/EIR)
//==============================================================================

interface ExprSynthState {
	lines: string[];
	varIndex: number;
	airDefs: Map<string, AIRDef>;
}

function synthesizeExprBased(
	doc: AIRDocument | CIRDocument | EIRDocument,
	opts: PythonSynthOptions,
): string {
	const { moduleName } = opts;
	const state: ExprSynthState = {
		lines: [],
		varIndex: 0,
		airDefs: new Map(),
	};

	// Build AIR def lookup
	for (const airDef of doc.airDefs) {
		state.airDefs.set(`${airDef.ns}:${airDef.name}`, airDef);
	}

	// Header
	state.lines.push("# Generated by SPIRAL Python Synthesizer");
	state.lines.push(`# Module: ${moduleName}`);
	state.lines.push(`# Document version: ${doc.version}`);
	state.lines.push("# IR Layer: expression-based");
	state.lines.push("");

	// Emit AIR defs as Python functions
	if (doc.airDefs.length > 0) {
		emitAirDefs(state, doc.airDefs);
		state.lines.push("");
	}

	// Emit node bindings
	state.lines.push("# Node bindings");
	const mutableCells = new Map<string, string>();
	const cellInitLines: string[] = [];

	for (const node of doc.nodes) {
		// Only emit bindings for expr nodes
		if (isExprNode(node)) {
			emitNodeBinding(state, node, mutableCells, cellInitLines);
		}
	}

	// Initialize mutable cells at the start
	if (cellInitLines.length > 0) {
		const insertIndex = state.lines.findIndex((l) => l.startsWith("# Node bindings"));
		if (insertIndex >= 0) {
			state.lines.splice(
				insertIndex,
				0,
				"# Mutable cells",
				...cellInitLines.map((l) => `    ${l}`),
				"",
			);
		}
	}

	state.lines.push("");

	// Emit result
	state.lines.push("# Result");
	state.lines.push(`print(v_${sanitizeId(doc.result)})`);
	state.lines.push("");

	return state.lines.join("\n");
}

function emitNodeBinding(
	state: ExprSynthState,
	node: Node | EirNode,
	mutableCells: Map<string, string>,
	cellInitLines: string[],
): void {
	const varName = `v_${sanitizeId(node.id)}`;

	// Skip already emitted
	if (state.lines.some((l) => l.startsWith(`${varName} =`))) {
		return;
	}

	const exprCode = synthesizeExpr(state, node.expr, mutableCells, cellInitLines);
	state.lines.push(`${varName} = ${exprCode}`);
	state.lines.push("");
}

function synthesizeExpr(
	state: ExprSynthState,
	expr: Expr | EirExpr,
	mutableCells: Map<string, string>,
	cellInitLines: string[],
): string {
	const kind = expr.kind;
	const refToPython = (nodeId: string): string => `v_${sanitizeId(nodeId)}`;
	const refOrInline = (val: string | Expr | EirExpr): string =>
		typeof val === "string" ? refToPython(val) : synthesizeExpr(state, val, mutableCells, cellInitLines);

	switch (kind) {
	case "lit": {
		const rawValue = expr.value;

		// Handle raw primitive values
		if (rawValue === null || rawValue === undefined) {
			return "None";
		}
		if (typeof rawValue === "boolean") {
			return rawValue ? "True" : "False";
		}
		if (typeof rawValue === "string") {
			return `"${rawValue}"`;
		}
		if (typeof rawValue === "number") {
			return String(rawValue);
		}
		if (Array.isArray(rawValue)) {
			// Handle raw arrays (list literals)
			return `[${rawValue.map((v: unknown) => formatUnknownValue(v)).join(", ")}]`;
		}
		// For complex Value objects, delegate to formatLiteral
		if (typeof rawValue === "object" && isValue(rawValue)) {
			return formatLiteral(rawValue);
		}
		return formatUnknownValue(rawValue);
	}

	case "ref": {
		return refToPython(expr.id);
	}

	case "var": {
		return expr.name;
	}

	case "call": {
		const qualName = `${expr.ns}:${expr.name}`;
		const mapping = OPERATOR_MAP[qualName];

		if (!mapping) {
			throw new Error(`Unsupported operator: ${qualName}`);
		}

		const argCodes = expr.args.map(a => refOrInline(a));

		if (mapping.customImpl) {
			return mapping.customImpl(argCodes);
		}

		if (argCodes.length === 1) {
			return `${mapping.pythonOp}${argCodes[0]}`;
		}
		if (argCodes.length === 2) {
			return `(${argCodes[0]} ${mapping.pythonOp} ${argCodes[1]})`;
		}

		throw new Error(`Unexpected arity for ${qualName}: ${argCodes.length}`);
	}

	case "if": {
		return `(${refToPython(expr.then)} if ${refToPython(expr.cond)} else ${refToPython(expr.else)})`;
	}

	case "let": {
		return `(lambda ${expr.name}: ${refToPython(expr.body)})(${refToPython(expr.value)})`;
	}

	case "airRef": {
		const qualName = `${expr.ns}:${expr.name}`;
		const airDef = state.airDefs.get(qualName);

		if (!airDef) {
			throw new Error(`Unknown AIR definition: ${qualName}`);
		}

		const argCodes = expr.args.map(refToPython);
		return `air_${expr.ns}_${expr.name}(${argCodes.join(", ")})`;
	}

	case "lambda": {
		const paramNames = expr.params.join(", ");
		return `(lambda ${paramNames}: ${refToPython(expr.body)})`;
	}

	case "callExpr": {
		const argCodes = expr.args.map(refToPython);
		return `${refToPython(expr.fn)}(${argCodes.join(", ")})`;
	}

	case "fix": {
		const varName = freshVar(state);
		return `(lambda ${varName}: ${refToPython(expr.fn)}(${varName}))(${varName})`;
	}

	case "do": {
		const exprs = expr.exprs;
		if (exprs.length === 0) return "None";
		const first = exprs[0];
		if (exprs.length === 1 && first !== undefined) return refOrInline(first);
		// Use Python tuple trick: (expr1, expr2, ..., exprN)[-1] to evaluate all and return last
		const exprCodes = exprs.map(e => refOrInline(e));
		return `(${exprCodes.join(", ")})[-1]`;
	}

	case "predicate": {
		return `(lambda ${expr.name}: True)`;
	}

	case "seq": {
		return `(lambda _: ${refOrInline(expr.then)})(${refOrInline(expr.first)})`;
	}

	case "assign": {
		const value = refOrInline(expr.value);

		if (!mutableCells.has(expr.target)) {
			const cellName = `_cell_${state.varIndex++}`;
			cellInitLines.push(`${cellName} = {"${expr.target}": ${value}}`);
			mutableCells.set(expr.target, cellName);
		}

		return "None";
	}

	case "while": {
		return `(lambda _: (${refOrInline(expr.body)}, None)[1] if ${refOrInline(expr.cond)} else None)(None)`;
	}

	case "iter": {
		return `[(lambda ${expr.var}: ${refOrInline(expr.body)})(item) for item in ${refOrInline(expr.iter)}][-1]`;
	}

	case "effect": {
		const argCodes = expr.args.map(a => refOrInline(a));
		return `print("${expr.op}", ${argCodes.join(", ")})`;
	}

	default: {
		throw new Error(`Unsupported expression kind: ${kind}`);
	}
	}
}

function emitAirDefs(state: ExprSynthState, airDefs: AIRDef[]): void {
	state.lines.push("# AIR definitions");

	for (const airDef of airDefs) {
		const params = airDef.params.join(", ");
		const funcName = `air_${airDef.ns}_${airDef.name}`;
		state.lines.push(`def ${funcName}(${params}):`);
		state.lines.push(`    return ${pythonExpr(airDef.body)}`);
		state.lines.push("");
	}
}

//==============================================================================
// CFG-Based Synthesis (LIR)
//==============================================================================

function synthesizeLIR(doc: LIRDocument, opts: PythonSynthOptions): string {
	const { moduleName } = opts;
	const lines: string[] = [];

	lines.push("# Generated by SPIRAL Python Synthesizer");
	lines.push(`# Module: ${moduleName}`);
	lines.push(`# Document version: ${doc.version}`);
	lines.push("# IR Layer: LIR (CFG-based)");
	lines.push("");
	lines.push("from typing import Dict, Any");
	lines.push("");

	// Find the result node (should be a block node)
	const resultNode = doc.nodes.find((n: LirHybridNode) => n.id === doc.result);
	if (!resultNode || !isBlockNode(resultNode)) {
		throw new Error("LIR document result must be a block node");
	}

	const blocks = resultNode.blocks;
	const entry = resultNode.entry;

	// Emit block definitions
	lines.push("# Blocks");
	lines.push("blocks = {");

	for (const block of blocks) {
		lines.push(`    "${block.id}": {`);
		lines.push(`        "instructions": ${JSON.stringify(block.instructions).replace(/"/g, '\\"')},`);
		lines.push(`        "terminator": ${JSON.stringify(block.terminator).replace(/"/g, '\\"')}`);
		lines.push("    },");
	}

	lines.push("}");
	lines.push("");

	// Emit execution engine
	lines.push("# Execution engine");
	lines.push("def execute_lir(blocks, entry):");
	lines.push("    vars = {}");
	lines.push("    current = entry");
	lines.push("    predecessor = None");
	lines.push("");
	lines.push("    while True:");
	lines.push("        if current not in blocks:");
	lines.push("            raise RuntimeError(f\"Unknown block: {current}\")");
	lines.push("");
	lines.push("        block = blocks[current]");
	lines.push("");
	lines.push("        for inst in block['instructions']:");
	lines.push("            kind = inst['kind']");
	lines.push("");
	lines.push("            if kind == 'assign':");
	lines.push("                vars[inst['target']] = eval_value(inst['value'], vars)");
	lines.push("");
	lines.push("            elif kind == 'op':");
	lines.push("                vars[inst['target']] = apply_operator(inst['ns'], inst['name'], [vars[a] for a in inst['args']])");
	lines.push("");
	lines.push("            elif kind == 'phi':");
	lines.push("                source_id = None");
	lines.push("                for s in inst['sources']:");
	lines.push("                    if s['block'] == predecessor:");
	lines.push("                        source_id = s['id']");
	lines.push("                        break");
	lines.push("                vars[inst['target']] = vars[source_id]");
	lines.push("");
	lines.push("        term = block['terminator']");
	lines.push("");
	lines.push("        if term['kind'] == 'jump':");
	lines.push("            predecessor = current");
	lines.push("            current = term['to']");
	lines.push("");
	lines.push("        elif term['kind'] == 'branch':");
	lines.push("            predecessor = current");
	lines.push("            current = term['then'] if vars[term['cond']] else term['else']");
	lines.push("");
	lines.push("        elif term['kind'] == 'return':");
	lines.push("            return vars.get(term.get('value', ''), None)");
	lines.push("");
	lines.push("        elif term['kind'] == 'exit':");
	lines.push("            return vars.get(term.get('code', ''), 0)");
	lines.push("");
	lines.push("");

	// Helper functions
	lines.push("def eval_value(val, vars):");
	lines.push("    if isinstance(val, dict):");
	lines.push("        kind = val.get('kind')");
	lines.push("        if kind == 'lit':");
	lines.push("            return val['value']");
	lines.push("        elif kind == 'var':");
	lines.push("            return vars[val['name']]");
	lines.push("    return val");
	lines.push("");
	lines.push("def apply_operator(ns, name, args):");
	lines.push("    if ns == 'core' and name == 'add': return args[0] + args[1]");
	lines.push("    if ns == 'core' and name == 'sub': return args[0] - args[1]");
	lines.push("    if ns == 'core' and name == 'mul': return args[0] * args[1]");
	lines.push("    if ns == 'core' and name == 'div': return int(args[0] // args[1])");
	lines.push("    raise RuntimeError(f\"Unknown operator: {ns}:{name}\")");
	lines.push("");
	lines.push("");

	// Main entry
	lines.push("if __name__ == \"__main__\":");
	lines.push(`    result = execute_lir(blocks, "${entry}")`);
	lines.push("    print(result)");

	return lines.join("\n");
}

//==============================================================================
// Utilities
//==============================================================================

function sanitizeId(id: string): string {
	return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

function freshVar(state: ExprSynthState): string {
	return `_v${state.varIndex++}`;
}

/** Type guard: checks if an unknown value has a 'kind' property consistent with Value */
function isValue(value: object): value is Value {
	return "kind" in value;
}

// Helper function to format unknown values (from raw test data)
function formatUnknownValue(value: unknown): string {
	if (value === null || value === undefined) return "None";
	if (typeof value === "boolean") return value ? "True" : "False";
	if (typeof value === "number") return String(value);
	if (typeof value === "string") return `"${value}"`;
	if (Array.isArray(value)) return `[${value.map(formatUnknownValue).join(", ")}]`;
	// Handle Value objects (objects with a 'kind' property)
	if (typeof value === "object" && isValue(value)) {
		return formatLiteral(value);
	}
	return JSON.stringify(value);
}

function formatLiteral(value: Value): string {
	// Handle void values
	if (value.kind === "void") {
		return "None";
	}
	if (Array.isArray(value)) return `[${value.map(formatLiteral).join(", ")}]`;
	if (value.kind === "option") {
		// Handle OptionVal with null value
		return value.value === null ? "None" : formatLiteral(value.value);
	}
	if (value.kind === "bool") {
		return value.value ? "True" : "False";
	}
	if (value.kind === "set") {
		const arr = Array.from(value.value);
		return `set([${arr.map((s) => JSON.stringify(s)).join(", ")}])`;
	}
	if (value.kind === "string") {
		return `"${value.value}"`;
	}
	if (value.kind === "int" || value.kind === "float") {
		return String(value.value);
	}
	if (value.kind === "list") {
		return `[${value.value.map(formatLiteral).join(", ")}]`;
	}
	if (value.kind === "map") {
		const entries = Array.from(value.value.entries());
		return `{${entries.map(([k, v]) => `${JSON.stringify(k)}: ${formatLiteral(v)}`).join(", ")}}`;
	}
	if (value.kind === "opaque") {
		return `"<opaque:${value.name}>";`;
	}
	if (value.kind === "error") {
		return `"<error:${value.code}>";`;
	}
	// Fallback for unhandled types
	return `"<unknown:${value.kind}>"`;
}

function pythonExpr(expr: Expr): string {
	switch (expr.kind) {
	case "ref":
		return `v_${sanitizeId(expr.id)}`;
	case "var":
		return expr.name;
	case "lit": {
		const litValue = expr.value;
		if (typeof litValue === "object" && litValue !== null && isValue(litValue)) {
			return formatLiteral(litValue);
		}
		return formatUnknownValue(litValue);
	}
	case "call": {
		const qualName = `${expr.ns}:${expr.name}`;
		const mapping = OPERATOR_MAP[qualName];

		if (!mapping) {
			return "None";
		}

		// Args can be strings (node refs) or inline Expr objects (in AIR defs)
		const argCodes = expr.args.map((arg) => {
			if (typeof arg === "string") {
				return `v_${sanitizeId(arg)}`;
			}
			return pythonExpr(arg);
		});

		if (mapping.customImpl) {
			return mapping.customImpl(argCodes);
		}

		if (argCodes.length === 1) {
			return `${mapping.pythonOp}${argCodes[0]}`;
		}
		if (argCodes.length === 2) {
			return `(${argCodes[0]} ${mapping.pythonOp} ${argCodes[1]})`;
		}

		return "None";
	}
	default:
		return "None";
	}
}
