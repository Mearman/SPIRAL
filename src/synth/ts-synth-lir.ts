// LIR (CFG-based) synthesis for TypeScript

import type { LIRDocument, LirHybridNode, BlockNode } from "../types.ts";
import { isBlockNode } from "../types.ts";
import type { TypeScriptSynthOptions } from "./ts-synth-shared.ts";

//==============================================================================
// Main entry for LIR documents
//==============================================================================

export function synthesizeLIR(doc: LIRDocument, opts: TypeScriptSynthOptions): string {
	const lines: string[] = [];
	emitLirHeader(lines, opts, doc.version);
	const resultNode = findResultNode(doc);
	emitBlockDefs(lines, resultNode);
	emitExecEngine(lines);
	emitLirHelpers(lines);
	lines.push(`const result = executeLir(blocks, "${resultNode.entry}");`);
	lines.push("console.log(result);");
	return lines.join("\n");
}

function findResultNode(doc: LIRDocument): BlockNode {
	const resultNode = doc.nodes.find((n: LirHybridNode) => n.id === doc.result);
	if (!resultNode || !isBlockNode(resultNode)) {
		throw new Error("LIR document result must be a block node");
	}
	return resultNode;
}

function emitLirHeader(lines: string[], opts: TypeScriptSynthOptions, version: string): void {
	if (opts.header) lines.push(opts.header);
	lines.push("// Generated by SPIRAL TypeScript Synthesizer");
	lines.push(`// Module: ${opts.moduleName}`);
	lines.push(`// Document version: ${version}`);
	lines.push("// IR Layer: LIR (CFG-based)");
	lines.push("");
}

function emitBlockDefs(lines: string[], resultNode: BlockNode): void {
	lines.push("// Blocks");
	lines.push("const blocks: Record<string, any> = {");
	for (const block of resultNode.blocks) {
		lines.push(`  "${block.id}": {`);
		lines.push(`    instructions: ${JSON.stringify(block.instructions)},`);
		lines.push(`    terminator: ${JSON.stringify(block.terminator)}`);
		lines.push("  },");
	}
	lines.push("};");
	lines.push("");
}

//==============================================================================
// Execution engine code generation
//==============================================================================

const EXEC_ENGINE_HEADER = [
	"// Execution engine",
	"function executeLir(blocks: Record<string, any>, entry: string): any {",
	"  const vars: Record<string, any> = {};",
	"  let current = entry;",
	"  let predecessor: string | null = null;",
	"",
	"  while (true) {",
];

const BLOCK_LOOKUP = [
	"    if (!(current in blocks)) {",
	"      throw new Error(`Unknown block: ${current}`);",
	"    }",
	"",
	"    const block = blocks[current];",
	"",
];

const INSTRUCTION_HANDLING = [
	"    for (const inst of block.instructions) {",
	"      if (inst.kind === \"assign\") {",
	"        vars[inst.target] = evalValue(inst.value, vars);",
	"      } else if (inst.kind === \"op\") {",
	"        vars[inst.target] = applyOperator(inst.ns, inst.name, inst.args.map((a: string) => vars[a]));",
	"      } else if (inst.kind === \"phi\") {",
	"        for (const s of inst.sources) {",
	"          if (s.block === predecessor) {",
	"            vars[inst.target] = vars[s.id];",
	"            break;",
	"          }",
	"        }",
	"      }",
	"    }",
	"",
];

const TERMINATOR_HANDLING = [
	"    const term = block.terminator;",
	"",
	"    if (term.kind === \"jump\") {",
	"      predecessor = current;",
	"      current = term.to;",
	"    } else if (term.kind === \"branch\") {",
	"      predecessor = current;",
	"      current = vars[term.cond] ? term.then : term.else;",
	"    } else if (term.kind === \"return\") {",
	"      return vars[term.value] ?? null;",
	"    } else if (term.kind === \"exit\") {",
	"      return vars[term.code] ?? 0;",
	"    }",
];

function emitExecEngine(lines: string[]): void {
	lines.push(...EXEC_ENGINE_HEADER);
	lines.push(...BLOCK_LOOKUP);
	lines.push(...INSTRUCTION_HANDLING);
	lines.push(...TERMINATOR_HANDLING);
	lines.push("  }");
	lines.push("}");
	lines.push("");
}

//==============================================================================
// Helper functions
//==============================================================================

const EVAL_VALUE_FN = [
	"function evalValue(val: any, vars: Record<string, any>): any {",
	"  if (typeof val === \"object\" && val !== null) {",
	"    if (val.kind === \"lit\") return val.value;",
	"    if (val.kind === \"var\") return vars[val.name];",
	"  }",
	"  return val;",
	"}",
	"",
];

const APPLY_OPERATOR_FN = [
	"function applyOperator(ns: string, name: string, args: any[]): any {",
	"  if (ns === \"core\" && name === \"add\") return args[0] + args[1];",
	"  if (ns === \"core\" && name === \"sub\") return args[0] - args[1];",
	"  if (ns === \"core\" && name === \"mul\") return args[0] * args[1];",
	"  if (ns === \"core\" && name === \"div\") return Math.floor(args[0] / args[1]);",
	"  throw new Error(`Unknown operator: ${ns}:${name}`);",
	"}",
	"",
];

function emitLirHelpers(lines: string[]): void {
	lines.push(...EVAL_VALUE_FN);
	lines.push(...APPLY_OPERATOR_FN);
}
