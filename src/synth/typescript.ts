// SPIRAL TypeScript Synthesizer
// Translates SPIRAL documents (AIR/CIR/EIR/LIR) to executable TypeScript code

import type {
	AIRDef, AIRDocument, CIRDocument, EIRDocument,
	Expr, EirExpr, Node, EirNode,
	LIRDocument,
	LirHybridNode,
	Value,
} from "../types.js";
import { isBlockNode, isExprNode } from "../types.js";

//==============================================================================
// Options and Types
//==============================================================================

export interface TypeScriptSynthOptions {
	/** Module name for generated code (used in comments) */
	moduleName?: string | undefined;
	/** Optional header comment to prepend */
	header?: string | undefined;
}

type Document = AIRDocument | CIRDocument | EIRDocument | LIRDocument;

//==============================================================================
// Operator Mappings
//==============================================================================

interface OperatorMapping {
	tsOp: string;
	customImpl?: (args: string[]) => string;
}

const OPERATOR_MAP: Record<string, OperatorMapping> = {
	"core:add": { tsOp: "+" },
	"core:sub": { tsOp: "-" },
	"core:mul": { tsOp: "*" },
	"core:div": { tsOp: "/", customImpl: (args) => `Math.floor(${args[0]} / ${args[1]})` },
	"core:mod": { tsOp: "%" },
	"core:pow": { tsOp: "**" },
	"core:neg": { tsOp: "-", customImpl: (args) => `(-${args[0]})` },
	"core:eq": { tsOp: "===" },
	"core:neq": { tsOp: "!==" },
	"core:lt": { tsOp: "<" },
	"core:lte": { tsOp: "<=" },
	"core:gt": { tsOp: ">" },
	"core:gte": { tsOp: ">=" },
	"bool:and": { tsOp: "&&" },
	"bool:or": { tsOp: "||" },
	"bool:not": { tsOp: "!", customImpl: (args) => `(!${args[0]})` },
	"list:length": { tsOp: "length", customImpl: (args) => `(${args[0]}).length` },
	"list:concat": { tsOp: "+", customImpl: (args) => `[...${args[0]}, ...${args[1]}]` },
	"string:concat": { tsOp: "+", customImpl: (args) => `(${args[0]} + ${args[1]})` },
};

/**
 * Type guard: checks whether a Document is a LIR document
 * by verifying it has nodes with block structure.
 */
function isLIRDocument(doc: Document): doc is LIRDocument {
	return "nodes" in doc && doc.nodes.some((n) => "blocks" in n && "entry" in n);
}

/**
 * Type guard: checks whether a Document is an expression-based document (AIR/CIR/EIR).
 */
function isExprBasedDocument(doc: Document): doc is AIRDocument | CIRDocument | EIRDocument {
	return "nodes" in doc && "airDefs" in doc && Array.isArray(doc.airDefs);
}

/**
 * Main entry point for TypeScript synthesis
 */
export function synthesizeTypeScript(doc: Document, opts: TypeScriptSynthOptions = {}): string {
	const { moduleName = "spiral_generated" } = opts;

	// Detect IR layer and dispatch
	if (isLIRDocument(doc)) {
		return synthesizeLIR(doc, { moduleName, header: opts.header });
	}
	if (isExprBasedDocument(doc)) {
		return synthesizeExprBased(doc, { moduleName, header: opts.header });
	}

	throw new Error("Unrecognized document format");
}

//==============================================================================
// Expression-Based Synthesis (AIR/CIR/EIR)
//==============================================================================

interface ExprSynthState {
	lines: string[];
	varIndex: number;
	airDefs: Map<string, AIRDef>;
	nodeMap: Map<string, Node | EirNode>;
	inlinedNodes: Set<string>;
}

function synthesizeExprBased(
	doc: AIRDocument | CIRDocument | EIRDocument,
	opts: TypeScriptSynthOptions,
): string {
	const { moduleName } = opts;
	const state: ExprSynthState = {
		lines: [],
		varIndex: 0,
		airDefs: new Map(),
		nodeMap: new Map(),
		inlinedNodes: new Set(),
	};

	// Build AIR def lookup
	for (const airDef of doc.airDefs) {
		state.airDefs.set(`${airDef.ns}:${airDef.name}`, airDef);
	}

	// Build node lookup for body inlining
	for (const node of doc.nodes) {
		if (isExprNode(node)) {
			state.nodeMap.set(node.id, node);
		}
	}

	// Header
	if (opts.header) {
		state.lines.push(opts.header);
	}
	state.lines.push("// Generated by SPIRAL TypeScript Synthesizer");
	state.lines.push(`// Module: ${moduleName}`);
	state.lines.push(`// Document version: ${doc.version}`);
	state.lines.push("// IR Layer: expression-based");
	state.lines.push("");

	// Emit AIR defs as TypeScript functions
	if (doc.airDefs.length > 0) {
		emitAirDefs(state, doc.airDefs);
		state.lines.push("");
	}

	// Pre-scan: mark body nodes that need inlining into lambda/let scopes
	for (const node of doc.nodes) {
		if (!isExprNode(node)) continue;
		const expr = node.expr;
		if (expr.kind === "lambda" || expr.kind === "let") {
			const bodyId = expr.body;
			const bodyNode = state.nodeMap.get(bodyId);
			if (bodyNode && exprHasFreeVars(bodyNode.expr)) {
				state.inlinedNodes.add(bodyId);
			}
		}
	}

	// Emit node bindings
	state.lines.push("// Node bindings");
	const mutableCells = new Map<string, boolean>();
	const cellInitLines: string[] = [];

	for (const node of doc.nodes) {
		if (isExprNode(node)) {
			emitNodeBinding(state, node, mutableCells, cellInitLines);
		}
	}

	// Initialize mutable cells at the start (as let declarations)
	if (cellInitLines.length > 0) {
		const insertIndex = state.lines.findIndex((l) => l.startsWith("// Node bindings"));
		if (insertIndex >= 0) {
			state.lines.splice(
				insertIndex,
				0,
				"// Mutable cells",
				...cellInitLines,
				"",
			);
		}
	}

	state.lines.push("");

	// Emit result
	state.lines.push("// Result");
	state.lines.push(`console.log(v_${sanitizeId(doc.result)});`);
	state.lines.push("");

	return state.lines.join("\n");
}

function emitNodeBinding(
	state: ExprSynthState,
	node: Node | EirNode,
	mutableCells: Map<string, boolean>,
	cellInitLines: string[],
): void {
	// Skip nodes that were inlined into lambda/let bodies
	if (state.inlinedNodes.has(node.id)) {
		return;
	}

	const varName = `v_${sanitizeId(node.id)}`;

	// Skip already emitted
	if (state.lines.some((l) => l.startsWith(`const ${varName} =`) || l.startsWith(`let ${varName} =`))) {
		return;
	}

	const exprCode = synthesizeExpr(state, node.expr, mutableCells, cellInitLines);
	state.lines.push(`const ${varName} = ${exprCode};`);
	state.lines.push("");
}

function synthesizeExpr(
	state: ExprSynthState,
	expr: Expr | EirExpr,
	mutableCells: Map<string, boolean>,
	cellInitLines: string[],
): string {
	const kind = expr.kind;
	const refToTs = (nodeId: string): string => `v_${sanitizeId(nodeId)}`;
	const refOrInline = (val: string | Expr | EirExpr): string =>
		typeof val === "string" ? refToTs(val) : synthesizeExpr(state, val, mutableCells, cellInitLines);

	switch (kind) {
	case "lit": {
		const rawValue = expr.value;

		// Handle raw primitive values
		if (rawValue === null || rawValue === undefined) {
			return "null";
		}
		if (typeof rawValue === "boolean") {
			return rawValue ? "true" : "false";
		}
		if (typeof rawValue === "string") {
			return `"${rawValue}"`;
		}
		if (typeof rawValue === "number") {
			return String(rawValue);
		}
		if (Array.isArray(rawValue)) {
			return `[${rawValue.map((v: unknown) => formatUnknownValue(v)).join(", ")}]`;
		}
		// For complex Value objects, delegate to formatLiteral
		if (typeof rawValue === "object" && isValue(rawValue)) {
			return formatLiteral(rawValue);
		}
		return formatUnknownValue(rawValue);
	}

	case "ref": {
		return refToTs(expr.id);
	}

	case "var": {
		return expr.name;
	}

	case "call": {
		const qualName = `${expr.ns}:${expr.name}`;
		const mapping = OPERATOR_MAP[qualName];

		if (!mapping) {
			throw new Error(`Unsupported operator: ${qualName}`);
		}

		const argCodes = expr.args.map(a => refOrInline(a));

		if (mapping.customImpl) {
			return mapping.customImpl(argCodes);
		}

		if (argCodes.length === 1) {
			return `${mapping.tsOp}${argCodes[0]}`;
		}
		if (argCodes.length === 2) {
			return `(${argCodes[0]} ${mapping.tsOp} ${argCodes[1]})`;
		}

		throw new Error(`Unexpected arity for ${qualName}: ${argCodes.length}`);
	}

	case "if": {
		return `(${refToTs(expr.cond)} ? ${refToTs(expr.then)} : ${refToTs(expr.else)})`;
	}

	case "let": {
		const bodyNode = state.nodeMap.get(expr.body);
		if (bodyNode && exprHasFreeVars(bodyNode.expr)) {
			state.inlinedNodes.add(expr.body);
			const bodyCode = synthesizeExpr(state, bodyNode.expr, mutableCells, cellInitLines);
			return `((${expr.name}: any) => ${bodyCode})(${refToTs(expr.value)})`;
		}
		return `((${expr.name}: any) => ${refToTs(expr.body)})(${refToTs(expr.value)})`;
	}

	case "airRef": {
		const qualName = `${expr.ns}:${expr.name}`;
		const airDef = state.airDefs.get(qualName);

		if (!airDef) {
			throw new Error(`Unknown AIR definition: ${qualName}`);
		}

		const argCodes = expr.args.map(refToTs);
		return `air_${expr.ns}_${expr.name}(${argCodes.join(", ")})`;
	}

	case "lambda": {
		const paramNames = expr.params.map(p => `${p}: any`).join(", ");
		const bodyNode = state.nodeMap.get(expr.body);
		// Inline the body if its expression contains free var references
		// (which would be out of scope as a top-level binding)
		if (bodyNode && exprHasFreeVars(bodyNode.expr)) {
			state.inlinedNodes.add(expr.body);
			const bodyCode = synthesizeExpr(state, bodyNode.expr, mutableCells, cellInitLines);
			return `((${paramNames}) => ${bodyCode})`;
		}
		return `((${paramNames}) => ${refToTs(expr.body)})`;
	}

	case "callExpr": {
		const argCodes = expr.args.map(refToTs);
		return `${refToTs(expr.fn)}(${argCodes.join(", ")})`;
	}

	case "fix": {
		// Z-combinator for strict evaluation: fix(f) = (g => g(g))(g => f((...a) => g(g)(...a)))
		const g1 = freshVar(state);
		const g2 = freshVar(state);
		const a = freshVar(state);
		return `((${g1}: any) => ${g1}(${g1}))((${g2}: any) => ${refToTs(expr.fn)}((...${a}: any[]) => ${g2}(${g2})(...${a})))`;
	}

	case "do": {
		const exprs = expr.exprs;
		if (exprs.length === 0) return "null";
		const first = exprs[0];
		if (exprs.length === 1 && first !== undefined) return refOrInline(first);
		// IIFE: evaluate all and return last
		const exprCodes = exprs.map(e => refOrInline(e));
		const last = exprCodes[exprCodes.length - 1];
		const stmts = exprCodes.slice(0, -1).map(e => `${e};`).join(" ");
		return `(() => { ${stmts} return ${last}; })()`;
	}

	case "predicate": {
		return `((${expr.name}: any) => true)`;
	}

	case "seq": {
		return `((_: any) => ${refOrInline(expr.then)})(${refOrInline(expr.first)})`;
	}

	case "assign": {
		const value = refOrInline(expr.value);

		if (!mutableCells.has(expr.target)) {
			cellInitLines.push(`let cell_${sanitizeId(expr.target)} = ${value};`);
			mutableCells.set(expr.target, true);
		}

		return "null";
	}

	case "while": {
		return `(() => { while (${refOrInline(expr.cond)}) { ${refOrInline(expr.body)}; } return null; })()`;
	}

	case "iter": {
		return `(() => { let _r: any; for (const ${expr.var} of ${refOrInline(expr.iter)}) { _r = ${refOrInline(expr.body)}; } return _r; })()`;
	}

	case "for": {
		return `(() => { for (let ${expr.var} = ${refOrInline(expr.init)}; ${refOrInline(expr.cond)}; ${expr.var} = ${refOrInline(expr.update)}) { ${refOrInline(expr.body)}; } return null; })()`;
	}

	case "try": {
		return `(() => { try { return ${refOrInline(expr.tryBody)}; } catch (${expr.catchParam}) { return ${refOrInline(expr.catchBody)}; } })()`;
	}

	case "effect": {
		const argCodes = expr.args.map(a => refOrInline(a));
		return `console.log("${expr.op}", ${argCodes.join(", ")})`;
	}

	case "refCell": {
		// Create a reference cell — store in a mutable cell variable
		if (!mutableCells.has(expr.target)) {
			cellInitLines.push(`let cell_${sanitizeId(expr.target)}_ref = ${refToTs(expr.target)};`);
			mutableCells.set(expr.target + "_ref", true);
		}
		return `cell_${sanitizeId(expr.target)}_ref`;
	}

	case "deref": {
		// Read from a reference cell
		return `cell_${sanitizeId(expr.target)}_ref`;
	}

	default: {
		throw new Error(`Unsupported expression kind: ${kind}`);
	}
	}
}

function emitAirDefs(state: ExprSynthState, airDefs: AIRDef[]): void {
	state.lines.push("// AIR definitions");

	for (const airDef of airDefs) {
		const params = airDef.params.map(p => `${p}: any`).join(", ");
		const funcName = `air_${airDef.ns}_${airDef.name}`;
		state.lines.push(`function ${funcName}(${params}) {`);
		state.lines.push(`  return ${tsExpr(airDef.body)};`);
		state.lines.push("}");
		state.lines.push("");
	}
}

//==============================================================================
// CFG-Based Synthesis (LIR)
//==============================================================================

function synthesizeLIR(doc: LIRDocument, opts: TypeScriptSynthOptions): string {
	const { moduleName } = opts;
	const lines: string[] = [];

	if (opts.header) {
		lines.push(opts.header);
	}
	lines.push("// Generated by SPIRAL TypeScript Synthesizer");
	lines.push(`// Module: ${moduleName}`);
	lines.push(`// Document version: ${doc.version}`);
	lines.push("// IR Layer: LIR (CFG-based)");
	lines.push("");

	// Find the result node (should be a block node)
	const resultNode = doc.nodes.find((n: LirHybridNode) => n.id === doc.result);
	if (!resultNode || !isBlockNode(resultNode)) {
		throw new Error("LIR document result must be a block node");
	}

	const blocks = resultNode.blocks;
	const entry = resultNode.entry;

	// Emit block definitions as a TypeScript object
	lines.push("// Blocks");
	lines.push("const blocks: Record<string, any> = {");

	for (const block of blocks) {
		lines.push(`  "${block.id}": {`);
		lines.push(`    instructions: ${JSON.stringify(block.instructions)},`);
		lines.push(`    terminator: ${JSON.stringify(block.terminator)}`);
		lines.push("  },");
	}

	lines.push("};");
	lines.push("");

	// Emit execution engine
	lines.push("// Execution engine");
	lines.push("function executeLir(blocks: Record<string, any>, entry: string): any {");
	lines.push("  const vars: Record<string, any> = {};");
	lines.push("  let current = entry;");
	lines.push("  let predecessor: string | null = null;");
	lines.push("");
	lines.push("  while (true) {");
	lines.push("    if (!(current in blocks)) {");
	lines.push("      throw new Error(`Unknown block: ${current}`);");
	lines.push("    }");
	lines.push("");
	lines.push("    const block = blocks[current];");
	lines.push("");
	lines.push("    for (const inst of block.instructions) {");
	lines.push("      if (inst.kind === \"assign\") {");
	lines.push("        vars[inst.target] = evalValue(inst.value, vars);");
	lines.push("      } else if (inst.kind === \"op\") {");
	lines.push("        vars[inst.target] = applyOperator(inst.ns, inst.name, inst.args.map((a: string) => vars[a]));");
	lines.push("      } else if (inst.kind === \"phi\") {");
	lines.push("        for (const s of inst.sources) {");
	lines.push("          if (s.block === predecessor) {");
	lines.push("            vars[inst.target] = vars[s.id];");
	lines.push("            break;");
	lines.push("          }");
	lines.push("        }");
	lines.push("      }");
	lines.push("    }");
	lines.push("");
	lines.push("    const term = block.terminator;");
	lines.push("");
	lines.push("    if (term.kind === \"jump\") {");
	lines.push("      predecessor = current;");
	lines.push("      current = term.to;");
	lines.push("    } else if (term.kind === \"branch\") {");
	lines.push("      predecessor = current;");
	lines.push("      current = vars[term.cond] ? term.then : term.else;");
	lines.push("    } else if (term.kind === \"return\") {");
	lines.push("      return vars[term.value] ?? null;");
	lines.push("    } else if (term.kind === \"exit\") {");
	lines.push("      return vars[term.code] ?? 0;");
	lines.push("    }");
	lines.push("  }");
	lines.push("}");
	lines.push("");

	// Helper functions
	lines.push("function evalValue(val: any, vars: Record<string, any>): any {");
	lines.push("  if (typeof val === \"object\" && val !== null) {");
	lines.push("    if (val.kind === \"lit\") return val.value;");
	lines.push("    if (val.kind === \"var\") return vars[val.name];");
	lines.push("  }");
	lines.push("  return val;");
	lines.push("}");
	lines.push("");
	lines.push("function applyOperator(ns: string, name: string, args: any[]): any {");
	lines.push("  if (ns === \"core\" && name === \"add\") return args[0] + args[1];");
	lines.push("  if (ns === \"core\" && name === \"sub\") return args[0] - args[1];");
	lines.push("  if (ns === \"core\" && name === \"mul\") return args[0] * args[1];");
	lines.push("  if (ns === \"core\" && name === \"div\") return Math.floor(args[0] / args[1]);");
	lines.push("  throw new Error(`Unknown operator: ${ns}:${name}`);");
	lines.push("}");
	lines.push("");

	// Main entry
	lines.push(`const result = executeLir(blocks, "${entry}");`);
	lines.push("console.log(result);");

	return lines.join("\n");
}

//==============================================================================
// Utilities
//==============================================================================

/**
 * Check whether an expression (or any of its inline sub-expressions)
 * contains a "var" reference. Var references are lambda/let parameter
 * names that only exist inside a function scope — emitting them as
 * top-level bindings would produce a ReferenceError.
 */
function exprHasFreeVars(expr: Expr | EirExpr): boolean {
	if (expr.kind === "var") return true;

	// Check inline sub-expressions (non-string fields that are Expr objects)
	if (expr.kind === "call") {
		return expr.args.some(a => typeof a !== "string" && exprHasFreeVars(a));
	}
	if (expr.kind === "do") {
		return expr.exprs.some(e => typeof e !== "string" && exprHasFreeVars(e));
	}
	if (expr.kind === "seq") {
		return (typeof expr.first !== "string" && exprHasFreeVars(expr.first)) ||
			(typeof expr.then !== "string" && exprHasFreeVars(expr.then));
	}
	if (expr.kind === "effect") {
		return expr.args.some(a => typeof a !== "string" && exprHasFreeVars(a));
	}
	if (expr.kind === "assign") {
		return typeof expr.value !== "string" && exprHasFreeVars(expr.value);
	}
	if (expr.kind === "while") {
		return (typeof expr.cond !== "string" && exprHasFreeVars(expr.cond)) ||
			(typeof expr.body !== "string" && exprHasFreeVars(expr.body));
	}
	if (expr.kind === "iter") {
		return (typeof expr.iter !== "string" && exprHasFreeVars(expr.iter)) ||
			(typeof expr.body !== "string" && exprHasFreeVars(expr.body));
	}
	if (expr.kind === "callExpr") {
		return (typeof expr.fn !== "string" && exprHasFreeVars(expr.fn)) ||
			expr.args.some(a => typeof a !== "string" && exprHasFreeVars(a));
	}
	if (expr.kind === "for") {
		return (typeof expr.init !== "string" && exprHasFreeVars(expr.init)) ||
			(typeof expr.cond !== "string" && exprHasFreeVars(expr.cond)) ||
			(typeof expr.update !== "string" && exprHasFreeVars(expr.update)) ||
			(typeof expr.body !== "string" && exprHasFreeVars(expr.body));
	}
	if (expr.kind === "try") {
		return (typeof expr.tryBody !== "string" && exprHasFreeVars(expr.tryBody)) ||
			(typeof expr.catchBody !== "string" && exprHasFreeVars(expr.catchBody));
	}

	return false;
}

function sanitizeId(id: string): string {
	return id.replace(/[^a-zA-Z0-9_]/g, "_");
}

function freshVar(state: ExprSynthState): string {
	return `_v${state.varIndex++}`;
}

/** Type guard: checks if an unknown value has a 'kind' property consistent with Value */
function isValue(value: object): value is Value {
	return "kind" in value;
}

function formatUnknownValue(value: unknown): string {
	if (value === null || value === undefined) return "null";
	if (typeof value === "boolean") return value ? "true" : "false";
	if (typeof value === "number") return String(value);
	if (typeof value === "string") return `"${value}"`;
	if (Array.isArray(value)) return `[${value.map(formatUnknownValue).join(", ")}]`;
	if (typeof value === "object" && isValue(value)) {
		return formatLiteral(value);
	}
	return JSON.stringify(value);
}

function formatLiteral(value: Value): string {
	if (value.kind === "void") {
		return "null";
	}
	if (Array.isArray(value)) return `[${value.map(formatLiteral).join(", ")}]`;
	if (value.kind === "option") {
		return value.value === null ? "null" : formatLiteral(value.value);
	}
	if (value.kind === "bool") {
		return value.value ? "true" : "false";
	}
	if (value.kind === "set") {
		const arr = Array.from(value.value);
		return `new Set([${arr.map((s) => JSON.stringify(s)).join(", ")}])`;
	}
	if (value.kind === "string") {
		return `"${value.value}"`;
	}
	if (value.kind === "int" || value.kind === "float") {
		return String(value.value);
	}
	if (value.kind === "list") {
		return `[${value.value.map(formatLiteral).join(", ")}]`;
	}
	if (value.kind === "map") {
		const entries = Array.from(value.value.entries());
		return `new Map([${entries.map(([k, v]) => `[${JSON.stringify(k)}, ${formatLiteral(v)}]`).join(", ")}])`;
	}
	if (value.kind === "opaque") {
		return `"<opaque:${value.name}>"`;
	}
	if (value.kind === "error") {
		return `"<error:${value.code}>"`;
	}
	return `"<unknown:${value.kind}>"`;
}

function tsExpr(expr: Expr): string {
	switch (expr.kind) {
	case "ref":
		return `v_${sanitizeId(expr.id)}`;
	case "var":
		return expr.name;
	case "lit": {
		const litValue = expr.value;
		if (typeof litValue === "object" && litValue !== null && isValue(litValue)) {
			return formatLiteral(litValue);
		}
		return formatUnknownValue(litValue);
	}
	case "call": {
		const qualName = `${expr.ns}:${expr.name}`;
		const mapping = OPERATOR_MAP[qualName];

		if (!mapping) {
			return "null";
		}

		const argCodes = expr.args.map((arg) => {
			if (typeof arg === "string") {
				return `v_${sanitizeId(arg)}`;
			}
			return tsExpr(arg);
		});

		if (mapping.customImpl) {
			return mapping.customImpl(argCodes);
		}

		if (argCodes.length === 1) {
			return `${mapping.tsOp}${argCodes[0]}`;
		}
		if (argCodes.length === 2) {
			return `(${argCodes[0]} ${mapping.tsOp} ${argCodes[1]})`;
		}

		return "null";
	}
	default:
		return "null";
	}
}
