// Expression-based synthesis (AIR/CIR/EIR) for TypeScript

import type {
	AIRDef, AIRDocument, CIRDocument, EIRDocument,
	Expr, EirExpr, Node, EirNode,
} from "../types.js";
import { isExprNode } from "../types.js";
import type { ExprSynthState, SynthContext, TypeScriptSynthOptions } from "./ts-synth-shared.js";
import { OPERATOR_MAP, sanitizeId, stableVarName, freshVar, isValue, formatLiteral, formatUnknownValue, tsExpr } from "./ts-synth-shared.js";
import { exprHasFreeVars, exprHasParamRefs, markInlinedBodies } from "./ts-synth-utils.js";

//==============================================================================
// Main entry for expression-based documents
//==============================================================================

export function synthesizeExprBased(
	doc: AIRDocument | CIRDocument | EIRDocument,
	opts: TypeScriptSynthOptions,
): string {
	const state = initState(doc);
	emitHeader(state, opts, doc.version);
	emitAirDefsIfPresent(state, doc.airDefs ?? []);
	preScanInlinedBodies(state, doc);
	emitAllNodeBindings(state, doc);
	emitResult(state, doc.result);
	return state.lines.join("\n");
}

function emitResult(state: ExprSynthState, result: string): void {
	state.lines.push("// Result");
	state.lines.push(`console.log(${stableVarName(result)});`);
	state.lines.push("");
}

function emitAirDefsIfPresent(state: ExprSynthState, airDefs: AIRDef[]): void {
	if (airDefs.length === 0) return;
	emitAirDefs(state, airDefs);
	state.lines.push("");
}

function initState(doc: AIRDocument | CIRDocument | EIRDocument): ExprSynthState {
	const state: ExprSynthState = {
		lines: [], varIndex: 0,
		airDefs: new Map(), nodeMap: new Map(), inlinedNodes: new Set(),
	};
	const airDefs = doc.airDefs ?? [];
	for (const d of airDefs) state.airDefs.set(`${d.ns}:${d.name}`, d);
	for (const n of doc.nodes) { if (isExprNode(n)) state.nodeMap.set(n.id, n); }
	return state;
}

function emitHeader(state: ExprSynthState, opts: TypeScriptSynthOptions, version: string): void {
	if (opts.header) state.lines.push(opts.header);
	state.lines.push("// Generated by SPIRAL TypeScript Synthesizer");
	state.lines.push(`// Module: ${opts.moduleName}`);
	state.lines.push(`// Document version: ${version}`);
	state.lines.push("// IR Layer: expression-based");
	state.lines.push("");
}

function preScanInlinedBodies(
	state: ExprSynthState,
	doc: AIRDocument | CIRDocument | EIRDocument,
): void {
	for (const node of doc.nodes) {
		if (!isExprNode(node)) continue;
		const expr = node.expr;
		if (expr.kind === "lambda") markInlinedBodies(state, expr.body, new Set(expr.params));
		else if (expr.kind === "let" && typeof expr.body === "string") markInlinedBodies(state, expr.body, new Set([expr.name]));
	}
}

function emitAllNodeBindings(
	state: ExprSynthState,
	doc: AIRDocument | CIRDocument | EIRDocument,
): void {
	state.lines.push("// Node bindings");
	const ctx: SynthContext = { state, mutableCells: new Map(), cellInitLines: [], paramScope: new Set() };
	for (const n of doc.nodes) { if (isExprNode(n)) emitNodeBinding(ctx, n); }
	if (ctx.cellInitLines.length > 0) {
		const idx = state.lines.findIndex((l) => l.startsWith("// Node bindings"));
		if (idx >= 0) state.lines.splice(idx, 0, "// Mutable cells", ...ctx.cellInitLines, "");
	}
	state.lines.push("");
}

function emitNodeBinding(ctx: SynthContext, node: Node | EirNode): void {
	if (ctx.state.inlinedNodes.has(node.id)) return;
	const varName = stableVarName(node.id);
	if (ctx.state.lines.some((l) => l.startsWith(`const ${varName} =`) || l.startsWith(`let ${varName} =`))) return;
	ctx.state.lines.push(`const ${varName} = ${synthesizeExpr(ctx, node.expr)};`);
	ctx.state.lines.push("");
}

function emitAirDefs(state: ExprSynthState, airDefs: AIRDef[]): void {
	state.lines.push("// AIR definitions");
	for (const d of airDefs) {
		const params = d.params.map(p => `${p}: any`).join(", ");
		state.lines.push(`function air_${d.ns}_${d.name}(${params}) {`);
		state.lines.push(`  return ${tsExpr(d.body)};`);
		state.lines.push("}");
		state.lines.push("");
	}
}

//==============================================================================
// Expression synthesis helpers
//==============================================================================

function refToTs(ctx: SynthContext, id: string): string {
	if (ctx.paramScope.has(id) && !ctx.state.nodeMap.has(id)) return id;
	return stableVarName(id);
}

function refOrInline(ctx: SynthContext, val: string | Expr | EirExpr): string {
	return typeof val === "string" ? refToTs(ctx, val) : synthesizeExpr(ctx, val);
}

function needsBodyInline(ctx: SynthContext, bodyId: string, params: Set<string>): Node | EirNode | undefined {
	const bodyNode = ctx.state.nodeMap.get(bodyId);
	if (!bodyNode) return undefined;
	if (exprHasFreeVars(bodyNode.expr) || exprHasParamRefs(bodyNode.expr, params, ctx.state.nodeMap)) {
		return bodyNode;
	}
	return undefined;
}

//==============================================================================
// Per-layer switch dispatchers
//==============================================================================

function synthLitValue(rawValue: unknown): string {
	if (rawValue === null || rawValue === undefined) return "null";
	if (typeof rawValue === "boolean") return rawValue ? "true" : "false";
	if (typeof rawValue === "string") return `"${rawValue}"`;
	if (typeof rawValue === "number") return String(rawValue);
	if (Array.isArray(rawValue)) return `[${rawValue.map((v: unknown) => formatUnknownValue(v)).join(", ")}]`;
	if (typeof rawValue === "object" && isValue(rawValue)) return formatLiteral(rawValue);
	return formatUnknownValue(rawValue);
}

function synthAirRefExpr(ctx: SynthContext, expr: Expr & { kind: "airRef" }): string {
	const qn = `${expr.ns}:${expr.name}`;
	if (!ctx.state.airDefs.has(qn)) throw new Error(`Unknown AIR definition: ${qn}`);
	return `air_${expr.ns}_${expr.name}(${expr.args.map((a) => refToTs(ctx, a)).join(", ")})`;
}

function synthAirExpr(ctx: SynthContext, expr: Expr | EirExpr): string | undefined {
	switch (expr.kind) {
	case "lit":
		return synthLitValue(expr.value);
	case "ref":
		return refToTs(ctx, expr.id);
	case "var":
		return expr.name;
	case "call":
		return synthCallExpr(ctx, expr);
	case "if":
		return `(${refOrInline(ctx, expr.cond)} ? ${refOrInline(ctx, expr.then)} : ${refOrInline(ctx, expr.else)})`;
	case "let":
		return synthLetExpr(ctx, expr);
	case "airRef":
		return synthAirRefExpr(ctx, expr);
	default:
		return undefined;
	}
}

function synthCallExpr(ctx: SynthContext, expr: Expr & { kind: "call" }): string {
	const qualName = `${expr.ns}:${expr.name}`;
	const mapping = OPERATOR_MAP[qualName];
	if (!mapping) throw new Error(`Unsupported operator: ${qualName}`);
	const argCodes = expr.args.map(a => refOrInline(ctx, a));
	if (mapping.customImpl) return mapping.customImpl(argCodes);
	if (argCodes.length === 1) return `${mapping.tsOp}${argCodes[0]}`;
	if (argCodes.length === 2) return `(${argCodes[0]} ${mapping.tsOp} ${argCodes[1]})`;
	throw new Error(`Unexpected arity for ${qualName}: ${argCodes.length}`);
}

function synthLetExpr(ctx: SynthContext, expr: Expr & { kind: "let" }): string {
	const letParams = new Set([...ctx.paramScope, expr.name]);
	const inlined = typeof expr.body === "string" ? needsBodyInline(ctx, expr.body, letParams) : undefined;
	if (inlined && typeof expr.body === "string") {
		ctx.state.inlinedNodes.add(expr.body);
		const bodyCode = synthesizeExpr({ ...ctx, paramScope: letParams }, inlined.expr);
		return `((${expr.name}: any) => ${bodyCode})(${refOrInline(ctx, expr.value)})`;
	}
	return `((${expr.name}: any) => ${refOrInline(ctx, expr.body)})(${refOrInline(ctx, expr.value)})`;
}

function synthCirExpr(ctx: SynthContext, expr: Expr | EirExpr): string | undefined {
	switch (expr.kind) {
	case "lambda":
		return synthLambdaExpr(ctx, expr);
	case "callExpr": {
		const fnCode = typeof expr.fn === "string" ? refToTs(ctx, expr.fn) : synthesizeExpr(ctx, expr.fn);
		const argCodes = expr.args.map(a => typeof a === "string" ? refToTs(ctx, a) : synthesizeExpr(ctx, a));
		return `${fnCode}(${argCodes.join(", ")})`;
	}
	case "fix": {
		const g1 = freshVar(ctx.state), g2 = freshVar(ctx.state), a = freshVar(ctx.state);
		return `((${g1}: any) => ${g1}(${g1}))((${g2}: any) => ${refToTs(ctx, expr.fn)}((...${a}: any[]) => ${g2}(${g2})(...${a})))`;
	}
	case "do":
		return synthDoExpr(ctx, expr);
	case "predicate":
		return `((${expr.name}: any) => true)`;
	default:
		return undefined;
	}
}

function synthLambdaExpr(ctx: SynthContext, expr: Expr & { kind: "lambda" }): string {
	const paramNames = expr.params.map(p => `${p}: any`).join(", ");
	const lambdaParams = new Set([...ctx.paramScope, ...expr.params]);
	const inlined = needsBodyInline(ctx, expr.body, lambdaParams);
	if (inlined) {
		ctx.state.inlinedNodes.add(expr.body);
		const bodyCode = synthesizeExpr({ ...ctx, paramScope: lambdaParams }, inlined.expr);
		return `((${paramNames}) => ${bodyCode})`;
	}
	return `((${paramNames}) => ${refToTs(ctx, expr.body)})`;
}

function synthDoExpr(ctx: SynthContext, expr: Expr & { kind: "do" }): string {
	if (expr.exprs.length === 0) return "null";
	const first = expr.exprs[0];
	if (expr.exprs.length === 1 && first !== undefined) return refOrInline(ctx, first);
	const codes = expr.exprs.map(e => refOrInline(ctx, e));
	const last = codes[codes.length - 1];
	const stmts = codes.slice(0, -1).map(e => `${e};`).join(" ");
	return `(() => { ${stmts} return ${last}; })()`;
}

function synthEirControlExpr(ctx: SynthContext, expr: Expr | EirExpr): string | undefined {
	switch (expr.kind) {
	case "seq":
		return `((_: any) => ${refOrInline(ctx, expr.then)})(${refOrInline(ctx, expr.first)})`;
	case "assign": {
		const value = refOrInline(ctx, expr.value);
		if (!ctx.mutableCells.has(expr.target)) {
			ctx.cellInitLines.push(`let cell_${sanitizeId(expr.target)} = ${value};`);
			ctx.mutableCells.set(expr.target, true);
		}
		return "null";
	}
	case "while":
		return `(() => { while (${refOrInline(ctx, expr.cond)}) { ${refOrInline(ctx, expr.body)}; } return null; })()`;
	case "iter":
		return `(() => { let _r: any; for (const ${expr.var} of ${refOrInline(ctx, expr.iter)}) { _r = ${refOrInline(ctx, expr.body)}; } return _r; })()`;
	case "for":
		return `(() => { for (let ${expr.var} = ${refOrInline(ctx, expr.init)}; ${refOrInline(ctx, expr.cond)}; ${expr.var} = ${refOrInline(ctx, expr.update)}) { ${refOrInline(ctx, expr.body)}; } return null; })()`;
	case "try":
		return `(() => { try { return ${refOrInline(ctx, expr.tryBody)}; } catch (${expr.catchParam}) { return ${refOrInline(ctx, expr.catchBody)}; } })()`;
	default:
		return undefined;
	}
}

function synthEirEffectExpr(ctx: SynthContext, expr: Expr | EirExpr): string | undefined {
	switch (expr.kind) {
	case "effect":
		return `console.log("${expr.op}", ${expr.args.map(a => refOrInline(ctx, a)).join(", ")})`;
	case "refCell": {
		if (!ctx.mutableCells.has(expr.target)) {
			ctx.cellInitLines.push(`let cell_${sanitizeId(expr.target)}_ref = ${refToTs(ctx, expr.target)};`);
			ctx.mutableCells.set(expr.target + "_ref", true);
		}
		return `cell_${sanitizeId(expr.target)}_ref`;
	}
	case "deref":
		return `cell_${sanitizeId(expr.target)}_ref`;
	default:
		return undefined;
	}
}

function synthAsyncExpr(ctx: SynthContext, expr: Expr | EirExpr): string | undefined {
	switch (expr.kind) {
	case "spawn":
		return `(async () => ${refOrInline(ctx, expr.task)})()`;
	case "await":
		return `await ${refOrInline(ctx, expr.future)}`;
	case "par":
		return `await Promise.all([${expr.branches.map(b => refOrInline(ctx, b)).join(", ")}])`;
	case "channel":
		return `new Channel(${expr.bufferSize ? refOrInline(ctx, expr.bufferSize) : "0"})`;
	case "send":
		return `await ${refOrInline(ctx, expr.channel)}.send(${refOrInline(ctx, expr.value)})`;
	case "recv":
		return `await ${refOrInline(ctx, expr.channel)}.recv()`;
	case "select":
		return `await Promise.race([${expr.futures.map(f => refOrInline(ctx, f)).join(", ")}])`;
	case "race":
		return `await Promise.race([${expr.tasks.map(t => refOrInline(ctx, t)).join(", ")}])`;
	default:
		return undefined;
	}
}

//==============================================================================
// synthesizeExpr - thin dispatcher
//==============================================================================

export function synthesizeExpr(ctx: SynthContext, expr: Expr | EirExpr): string {
	const result = synthAirExpr(ctx, expr) ?? synthCirExpr(ctx, expr) ?? synthEirControlExpr(ctx, expr) ?? synthEirEffectExpr(ctx, expr) ?? synthAsyncExpr(ctx, expr);
	if (result !== undefined) return result;
	throw new Error(`Unsupported expression kind: ${expr.kind}`);
}
