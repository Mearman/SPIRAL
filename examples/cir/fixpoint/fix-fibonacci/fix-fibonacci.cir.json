{
	"$schema": "https://raw.githubusercontent.com/Mearman/SPIRAL/main/cir.schema.json",
	"formula": "fix fib_rec where fib_rec = lambda rec. lambda n. if n <= 1 then n else rec(n-1) + rec(n-2)",
	"example": "fibonacci(7) = 13",
	"version": "1.0.0",
	"description": "Fibonacci using the fix combinator for recursion. The fix combinator enables self-reference by computing the least fixed point of a function. fix F = F (fix F), allowing the function F to receive itself as its first parameter, enabling recursion. Fibonacci: fib(n) = if n <= 1 then n else fib(n-1) + fib(n-2).",
	"airDefs": [
		{
			"ns": "core",
			"name": "lte",
			"params": [
				"a",
				"b"
			],
			"result": {
				"kind": "bool"
			},
			"body": {
				"kind": "ref",
				"id": "a"
			}
		},
		{
			"ns": "core",
			"name": "sub",
			"params": [
				"a",
				"b"
			],
			"result": {
				"kind": "int"
			},
			"body": {
				"kind": "ref",
				"id": "a"
			}
		},
		{
			"ns": "core",
			"name": "add",
			"params": [
				"a",
				"b"
			],
			"result": {
				"kind": "int"
			},
			"body": {
				"kind": "ref",
				"id": "a"
			}
		}
	],
	"nodes": [
		{
			"id": "zero",
			"expr": {
				"kind": "lit",
				"type": {
					"kind": "int"
				},
				"value": 0
			}
		},
		{
			"id": "one",
			"expr": {
				"kind": "lit",
				"type": {
					"kind": "int"
				},
				"value": 1
			}
		},
		{
			"id": "two",
			"expr": {
				"kind": "lit",
				"type": {
					"kind": "int"
				},
				"value": 2
			}
		},
		{
			"id": "seven",
			"expr": {
				"kind": "lit",
				"type": {
					"kind": "int"
				},
				"value": 7
			}
		},
		{
			"id": "thirteen",
			"expr": {
				"kind": "lit",
				"type": {
					"kind": "int"
				},
				"value": 13
			}
		},
		{
			"id": "fibRec",
			"expr": {
				"kind": "lambda",
				"type": {
					"kind": "fn",
					"params": [
						{
							"kind": "fn",
							"params": [
								{
									"kind": "int"
								}
							],
							"returns": {
								"kind": "int"
							}
						}
					],
					"returns": {
						"kind": "fn",
						"params": [
							{
								"kind": "int"
							}
						],
						"returns": {
							"kind": "int"
						}
					}
				},
				"params": [
					"rec"
				],
				"body": "fibInner"
			}
		},
		{
			"id": "fibInner",
			"expr": {
				"kind": "lambda",
				"type": {
					"kind": "fn",
					"params": [
						{
							"kind": "int"
						}
					],
					"returns": {
						"kind": "int"
					}
				},
				"params": [
					"n"
				],
				"body": "fibBody"
			}
		},
		{
			"id": "fibBody",
			"expr": {
				"kind": "let",
				"name": "isLeOne",
				"value": "checkLeOne",
				"body": "branchResult"
			}
		},
		{
			"id": "checkLeOne",
			"expr": {
				"kind": "call",
				"ns": "core",
				"name": "lte",
				"args": [
					"n",
					"one"
				]
			}
		},
		{
			"id": "branchResult",
			"expr": {
				"kind": "if",
				"type": {
					"kind": "int"
				},
				"cond": "isLeOne",
				"then": "n",
				"else": "recursiveCase"
			}
		},
		{
			"id": "recursiveCase",
			"expr": {
				"kind": "let",
				"name": "nMinusOne",
				"value": "decrementOne",
				"body": "computeFibMinusOne"
			}
		},
		{
			"id": "decrementOne",
			"expr": {
				"kind": "call",
				"ns": "core",
				"name": "sub",
				"args": [
					"n",
					"one"
				]
			}
		},
		{
			"id": "computeFibMinusOne",
			"expr": {
				"kind": "let",
				"name": "fibNMinusOne",
				"value": "recCallOne",
				"body": "computeFibMinusTwo"
			}
		},
		{
			"id": "recCallOne",
			"expr": {
				"kind": "callExpr",
				"args": [
					"nMinusOne"
				],
				"fn": "rec"
			}
		},
		{
			"id": "computeFibMinusTwo",
			"expr": {
				"kind": "let",
				"name": "nMinusTwo",
				"value": "decrementTwo",
				"body": "computeFibMinusTwoVal"
			}
		},
		{
			"id": "decrementTwo",
			"expr": {
				"kind": "call",
				"ns": "core",
				"name": "sub",
				"args": [
					"n",
					"two"
				]
			}
		},
		{
			"id": "computeFibMinusTwoVal",
			"expr": {
				"kind": "let",
				"name": "fibNMinusTwo",
				"value": "recCallTwo",
				"body": "sumResult"
			}
		},
		{
			"id": "recCallTwo",
			"expr": {
				"kind": "callExpr",
				"args": [
					"nMinusTwo"
				],
				"fn": "rec"
			}
		},
		{
			"id": "sumResult",
			"expr": {
				"kind": "call",
				"ns": "core",
				"name": "add",
				"args": [
					"fibNMinusOne",
					"fibNMinusTwo"
				]
			}
		},
		{
			"id": "fibFixed",
			"expr": {
				"kind": "fix",
				"type": {
					"kind": "fn",
					"params": [
						{
							"kind": "int"
						}
					],
					"returns": {
						"kind": "int"
					}
				},
				"fn": "fibRec"
			}
		},
		{
			"id": "result",
			"expr": {
				"kind": "callExpr",
				"args": [
					"seven"
				],
				"fn": "fibFixed"
			}
		}
	],
	"result": "result",
	"expected_result": 13,
	"computation_trace": [
		{
			"description": "fix fibRec binds fibRec to its own application",
			"step": 1
		},
		{
			"description": "fibFixed = fibRec(fibFixed)",
			"step": 2
		},
		{
			"description": "Call fibFixed(7)",
			"step": 3
		},
		{
			"action": "compute fib(6) + fib(5)",
			"check": "7 <= 1",
			"n": 7,
			"result": false,
			"step": 4
		},
		{
			"action": "compute fib(5) + fib(4)",
			"check": "6 <= 1",
			"n": 6,
			"result": false,
			"step": 5
		},
		{
			"action": "compute fib(4) + fib(3)",
			"check": "5 <= 1",
			"n": 5,
			"result": false,
			"step": 6
		},
		{
			"action": "compute fib(3) + fib(2)",
			"check": "4 <= 1",
			"n": 4,
			"result": false,
			"step": 7
		},
		{
			"action": "compute fib(2) + fib(1)",
			"check": "3 <= 1",
			"n": 3,
			"result": false,
			"step": 8
		},
		{
			"action": "compute fib(1) + fib(0)",
			"check": "2 <= 1",
			"n": 2,
			"result": false,
			"step": 9
		},
		{
			"check": "1 <= 1",
			"n": 1,
			"result": true,
			"returns": 1,
			"step": 10
		},
		{
			"check": "0 <= 1",
			"n": 0,
			"result": true,
			"returns": 0,
			"step": 11
		},
		{
			"description": "fib(2) = fib(1) + fib(0) = 1 + 0 = 1",
			"step": 12
		},
		{
			"description": "fib(3) = fib(2) + fib(1) = 1 + 1 = 2",
			"step": 13
		},
		{
			"description": "fib(4) = fib(3) + fib(2) = 2 + 1 = 3",
			"step": 14
		},
		{
			"description": "fib(5) = fib(4) + fib(3) = 3 + 2 = 5",
			"step": 15
		},
		{
			"description": "fib(6) = fib(5) + fib(4) = 5 + 3 = 8",
			"step": 16
		},
		{
			"description": "fib(7) = fib(6) + fib(5) = 8 + 5 = 13",
			"step": 17
		}
	],
	"notes": [
		"The fix combinator solves the self-reference problem in lambda calculus",
		"fix F expands to F(fix F), giving F access to itself via its first parameter",
		"Fibonacci is the classic example of tree recursion - each call spawns two more calls",
		"Type of fix: (T -> T) -> T for any type T",
		"Here T = int -> int, so fix has type ((int -> int) -> (int -> int)) -> (int -> int)",
		"The fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ..."
	]
}
