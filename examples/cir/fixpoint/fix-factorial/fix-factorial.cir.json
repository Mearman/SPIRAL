{
	"$schema": "https://raw.githubusercontent.com/Mearman/SPIRAL/main/cir.schema.json",
	"formula": "fix factorial_rec where factorial_rec = lambda rec. lambda n. if n <= 1 then 1 else n * rec(n-1)",
	"example": "factorial(5) = 120",
	"version": "1.0.0",
	"description": "Factorial using the fix combinator for recursion. The fix combinator enables self-reference by computing the least fixed point of a function. fix F = F (fix F), allowing the function F to receive itself as its first parameter, enabling recursion.",
	"airDefs": [
		{
			"ns": "core",
			"name": "lte",
			"params": [
				"a",
				"b"
			],
			"result": {
				"kind": "bool"
			},
			"body": {
				"kind": "ref",
				"id": "a"
			}
		},
		{
			"ns": "core",
			"name": "sub",
			"params": [
				"a",
				"b"
			],
			"result": {
				"kind": "int"
			},
			"body": {
				"kind": "ref",
				"id": "a"
			}
		},
		{
			"ns": "core",
			"name": "mul",
			"params": [
				"a",
				"b"
			],
			"result": {
				"kind": "int"
			},
			"body": {
				"kind": "ref",
				"id": "a"
			}
		}
	],
	"nodes": [
		{
			"id": "one",
			"expr": {
				"kind": "lit",
				"type": {
					"kind": "int"
				},
				"value": 1
			}
		},
		{
			"id": "five",
			"expr": {
				"kind": "lit",
				"type": {
					"kind": "int"
				},
				"value": 5
			}
		},
		{
			"id": "factorialRec",
			"expr": {
				"kind": "lambda",
				"type": {
					"kind": "fn",
					"params": [
						{
							"kind": "fn",
							"params": [
								{
									"kind": "int"
								}
							],
							"returns": {
								"kind": "int"
							}
						}
					],
					"returns": {
						"kind": "fn",
						"params": [
							{
								"kind": "int"
							}
						],
						"returns": {
							"kind": "int"
						}
					}
				},
				"params": [
					"rec"
				],
				"body": "factorialInner"
			}
		},
		{
			"id": "factorialInner",
			"expr": {
				"kind": "lambda",
				"type": {
					"kind": "fn",
					"params": [
						{
							"kind": "int"
						}
					],
					"returns": {
						"kind": "int"
					}
				},
				"params": [
					"n"
				],
				"body": "factorialBody"
			}
		},
		{
			"id": "factorialBody",
			"expr": {
				"kind": "let",
				"name": "isLeOne",
				"value": "checkLeOne",
				"body": "branchResult"
			}
		},
		{
			"id": "checkLeOne",
			"expr": {
				"kind": "call",
				"ns": "core",
				"name": "lte",
				"args": [
					"n",
					"one"
				]
			}
		},
		{
			"id": "branchResult",
			"expr": {
				"kind": "if",
				"type": {
					"kind": "int"
				},
				"cond": "isLeOne",
				"then": "one",
				"else": "recursiveCase"
			}
		},
		{
			"id": "recursiveCase",
			"expr": {
				"kind": "let",
				"name": "nMinusOne",
				"value": "decrementN",
				"body": "multiplyResult"
			}
		},
		{
			"id": "decrementN",
			"expr": {
				"kind": "call",
				"ns": "core",
				"name": "sub",
				"args": [
					"n",
					"one"
				]
			}
		},
		{
			"id": "multiplyResult",
			"expr": {
				"kind": "let",
				"name": "recResult",
				"value": "recursiveCall",
				"body": "finalMultiply"
			}
		},
		{
			"id": "recursiveCall",
			"expr": {
				"kind": "callExpr",
				"args": [
					"nMinusOne"
				],
				"fn": "rec"
			}
		},
		{
			"id": "finalMultiply",
			"expr": {
				"kind": "call",
				"ns": "core",
				"name": "mul",
				"args": [
					"n",
					"recResult"
				]
			}
		},
		{
			"id": "factorialFixed",
			"expr": {
				"kind": "fix",
				"type": {
					"kind": "fn",
					"params": [
						{
							"kind": "int"
						}
					],
					"returns": {
						"kind": "int"
					}
				},
				"fn": "factorialRec"
			}
		},
		{
			"id": "result",
			"expr": {
				"kind": "callExpr",
				"args": [
					"five"
				],
				"fn": "factorialFixed"
			}
		}
	],
	"result": "result",
	"expected_result": 120,
	"computation_trace": [
		{
			"description": "fix factorialRec binds factorialRec to its own application",
			"step": 1
		},
		{
			"description": "factorialFixed = factorialRec(factorialFixed)",
			"step": 2
		},
		{
			"description": "Call factorialFixed(5)",
			"step": 3
		},
		{
			"action": "recursive case",
			"check": "5 <= 1",
			"n": 5,
			"result": false,
			"step": 4
		},
		{
			"description": "Compute 5 - 1 = 4",
			"step": 5
		},
		{
			"description": "Recursive call: rec(4) = factorialFixed(4)",
			"step": 6
		},
		{
			"action": "recursive case",
			"check": "4 <= 1",
			"n": 4,
			"result": false,
			"step": 7
		},
		{
			"description": "Compute 4 - 1 = 3",
			"step": 8
		},
		{
			"description": "Recursive call: rec(3) = factorialFixed(3)",
			"step": 9
		},
		{
			"action": "recursive case",
			"check": "3 <= 1",
			"n": 3,
			"result": false,
			"step": 10
		},
		{
			"description": "Compute 3 - 1 = 2",
			"step": 11
		},
		{
			"description": "Recursive call: rec(2) = factorialFixed(2)",
			"step": 12
		},
		{
			"action": "recursive case",
			"check": "2 <= 1",
			"n": 2,
			"result": false,
			"step": 13
		},
		{
			"description": "Compute 2 - 1 = 1",
			"step": 14
		},
		{
			"description": "Recursive call: rec(1) = factorialFixed(1)",
			"step": 15
		},
		{
			"action": "base case returns 1",
			"check": "1 <= 1",
			"n": 1,
			"result": true,
			"step": 16
		},
		{
			"description": "Unwind: 2 * 1 = 2",
			"step": 17
		},
		{
			"description": "Unwind: 3 * 2 = 6",
			"step": 18
		},
		{
			"description": "Unwind: 4 * 6 = 24",
			"step": 19
		},
		{
			"description": "Unwind: 5 * 24 = 120",
			"step": 20
		}
	],
	"notes": [
		"The fix combinator solves the self-reference problem in lambda calculus",
		"fix F expands to F(fix F), giving F access to itself via its first parameter",
		"Type of fix: (T -> T) -> T for any type T",
		"Here T = int -> int, so fix has type ((int -> int) -> (int -> int)) -> (int -> int)"
	]
}
