{
	"$schema": "https://json-schema.org/draft/2020-12/schema",
	"$id": "https://raw.githubusercontent.com/Mearman/SPIRAL/refs/heads/main/spiral.schema.json",
	"$defs": {
		"AIRDef": {
			"title": "AIR Definition",
			"description": "Reusable pure function definition scoped to AIR",
			"type": "object",
			"properties": {
				"body": {
					"$ref": "#/$defs/AirExpr"
				},
				"name": {
					"type": "string"
				},
				"ns": {
					"type": "string"
				},
				"params": {
					"type": "array",
					"items": {
						"type": "string"
					}
				},
				"result": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"ns",
				"name",
				"params",
				"result",
				"body"
			],
			"id": "AIRDef"
		},
		"AirExpr": {
			"anyOf": [
				{
					"$ref": "#/$defs/LitExpr"
				},
				{
					"$ref": "#/$defs/RefExpr"
				},
				{
					"$ref": "#/$defs/VarExpr"
				},
				{
					"$ref": "#/$defs/CallExpr"
				},
				{
					"$ref": "#/$defs/IfExpr"
				},
				{
					"$ref": "#/$defs/LetExpr"
				},
				{
					"$ref": "#/$defs/AirRefExpr"
				},
				{
					"$ref": "#/$defs/PredicateExpr"
				},
				{
					"$ref": "#/$defs/RecordExpr"
				},
				{
					"$ref": "#/$defs/ListOfExpr"
				},
				{
					"$ref": "#/$defs/MatchExpr"
				},
				{
					"$ref": "#/$defs/RefPointerExpr"
				}
			],
			"description": "Pure, bounded expression (no recursion or side effects)",
			"id": "AirExpr",
			"title": "AIR Expression"
		},
		"AirRefExpr": {
			"title": "AIR Definition Reference",
			"description": "Call to a reusable AIR definition by namespace and name",
			"type": "object",
			"properties": {
				"args": {
					"type": "array",
					"items": {
						"type": "string"
					}
				},
				"kind": {
					"type": "string",
					"const": "airRef"
				},
				"name": {
					"type": "string"
				},
				"ns": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"ns",
				"name",
				"args"
			],
			"id": "AirRefExpr"
		},
		"AsyncFnType": {
			"title": "Async Function Type",
			"description": "Asynchronous function returning a Future",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "async"
				},
				"params": {
					"type": "array",
					"items": {
						"$ref": "#/$defs/Type"
					}
				},
				"returns": {
					"$ref": "#/$defs/FutureType"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"params",
				"returns"
			],
			"id": "AsyncFnType"
		},
		"BoolType": {
			"title": "Boolean Type",
			"description": "Boolean truth value type",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "bool"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "BoolType"
		},
		"CallExpr": {
			"title": "Call Expression",
			"description": "Namespaced operator call (e.g., core:add)",
			"type": "object",
			"properties": {
				"args": {
					"type": "array",
					"items": {
						"anyOf": [
							{
								"type": "string"
							},
							{
								"$ref": "#/$defs/Expr"
							}
						]
					}
				},
				"kind": {
					"type": "string",
					"const": "call"
				},
				"name": {
					"type": "string"
				},
				"ns": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"ns",
				"name",
				"args"
			],
			"id": "CallExpr"
		},
		"CallFnExpr": {
			"title": "Function Call Expression",
			"description": "Invocation of a first-class function node with arguments",
			"type": "object",
			"properties": {
				"args": {
					"type": "array",
					"items": {
						"anyOf": [
							{
								"type": "string"
							},
							{
								"$ref": "#/$defs/Expr"
							}
						]
					}
				},
				"fn": {
					"type": "string"
				},
				"kind": {
					"type": "string",
					"const": "callExpr"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"fn",
				"args"
			],
			"id": "CallFnExpr"
		},
		"CallPat": {
			"title": "Call Pattern",
			"description": "Matches call expressions with namespace, name, and argument patterns",
			"type": "object",
			"properties": {
				"args": {
					"type": "array",
					"items": {
						"$ref": "#/$defs/ExprPattern"
					}
				},
				"kind": {
					"type": "string",
					"const": "callPat"
				},
				"name": {
					"type": "string"
				},
				"ns": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"ns",
				"name",
				"args"
			],
			"id": "CallPat"
		},
		"ChannelType": {
			"title": "Channel Type",
			"description": "Typed communication channel between concurrent tasks",
			"type": "object",
			"properties": {
				"channelType": {
					"type": "string",
					"enum": [
						"mpsc",
						"spsc",
						"mpmc",
						"broadcast"
					]
				},
				"kind": {
					"type": "string",
					"const": "channel"
				},
				"of": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"channelType",
				"of"
			],
			"id": "ChannelType"
		},
		"CirExpr": {
			"anyOf": [
				{
					"$ref": "#/$defs/LitExpr"
				},
				{
					"$ref": "#/$defs/RefExpr"
				},
				{
					"$ref": "#/$defs/VarExpr"
				},
				{
					"$ref": "#/$defs/CallExpr"
				},
				{
					"$ref": "#/$defs/IfExpr"
				},
				{
					"$ref": "#/$defs/LetExpr"
				},
				{
					"$ref": "#/$defs/AirRefExpr"
				},
				{
					"$ref": "#/$defs/PredicateExpr"
				},
				{
					"$ref": "#/$defs/RecordExpr"
				},
				{
					"$ref": "#/$defs/ListOfExpr"
				},
				{
					"$ref": "#/$defs/MatchExpr"
				},
				{
					"$ref": "#/$defs/RefPointerExpr"
				},
				{
					"$ref": "#/$defs/LambdaExpr"
				},
				{
					"$ref": "#/$defs/CallFnExpr"
				},
				{
					"$ref": "#/$defs/FixExpr"
				},
				{
					"$ref": "#/$defs/DoExpr"
				},
				{
					"$ref": "#/$defs/MatchExprExpr"
				},
				{
					"$ref": "#/$defs/QuoteExpr"
				},
				{
					"$ref": "#/$defs/SpliceExpr"
				}
			],
			"description": "Functional expression with lambdas and recursion (no side effects)",
			"id": "CirExpr",
			"title": "CIR Expression"
		},
		"Def": {
			"title": "Definition",
			"description": "A definition in $defs (expression, node, or type)",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"expr": {
					"anyOf": [
						{
							"$ref": "#/$defs/Expr"
						},
						{
							"type": "string"
						}
					]
				},
				"node": {
					"anyOf": [
						{
							"type": "object",
							"properties": {
								"type": {
									"$ref": "#/$defs/Type"
								},
								"expr": {
									"$ref": "#/$defs/Expr"
								},
								"id": {
									"type": "string"
								}
							},
							"additionalProperties": false,
							"required": [
								"id",
								"expr"
							]
						},
						{
							"type": "object",
							"properties": {
								"type": {
									"$ref": "#/$defs/Type"
								},
								"blocks": {
									"type": "array",
									"items": {
										"$ref": "#/$defs/LirBlock"
									}
								},
								"entry": {
									"type": "string"
								},
								"id": {
									"type": "string"
								}
							},
							"additionalProperties": false,
							"required": [
								"id",
								"blocks",
								"entry"
							]
						}
					]
				}
			},
			"additionalProperties": false,
			"id": "Def"
		},
		"DoExpr": {
			"title": "Do Expression",
			"description": "Sequence of expressions returning the last value",
			"type": "object",
			"properties": {
				"exprs": {
					"type": "array",
					"items": {
						"anyOf": [
							{
								"type": "string"
							},
							{
								"$ref": "#/$defs/Expr"
							}
						]
					}
				},
				"kind": {
					"type": "string",
					"const": "do"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"exprs"
			],
			"id": "DoExpr"
		},
		"Expr": {
			"anyOf": [
				{
					"$ref": "#/$defs/LitExpr"
				},
				{
					"$ref": "#/$defs/RefExpr"
				},
				{
					"$ref": "#/$defs/VarExpr"
				},
				{
					"$ref": "#/$defs/CallExpr"
				},
				{
					"$ref": "#/$defs/IfExpr"
				},
				{
					"$ref": "#/$defs/LetExpr"
				},
				{
					"$ref": "#/$defs/AirRefExpr"
				},
				{
					"$ref": "#/$defs/PredicateExpr"
				},
				{
					"$ref": "#/$defs/RecordExpr"
				},
				{
					"$ref": "#/$defs/ListOfExpr"
				},
				{
					"$ref": "#/$defs/MatchExpr"
				},
				{
					"$ref": "#/$defs/RefPointerExpr"
				},
				{
					"$ref": "#/$defs/LambdaExpr"
				},
				{
					"$ref": "#/$defs/CallFnExpr"
				},
				{
					"$ref": "#/$defs/FixExpr"
				},
				{
					"$ref": "#/$defs/DoExpr"
				}
			],
			"description": "Wide expression union used for recursive inline expressions",
			"id": "Expr",
			"title": "Expression"
		},
		"ExprPattern": {
			"anyOf": [
				{
					"$ref": "#/$defs/LitPat"
				},
				{
					"$ref": "#/$defs/VarPat"
				},
				{
					"$ref": "#/$defs/CallPat"
				},
				{
					"$ref": "#/$defs/LambdaPat"
				},
				{
					"$ref": "#/$defs/WildcardPat"
				}
			],
			"description": "Structural pattern for matching expression ASTs",
			"id": "ExprPattern",
			"title": "Expression Pattern"
		},
		"FixExpr": {
			"title": "Fix-Point Combinator",
			"description": "Y-combinator for general recursion (CIR and above)",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"fn": {
					"type": "string"
				},
				"kind": {
					"type": "string",
					"const": "fix"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"fn",
				"type"
			],
			"id": "FixExpr"
		},
		"FloatType": {
			"title": "Float Type",
			"description": "IEEE 754 floating-point type",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "float"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "FloatType"
		},
		"FnType": {
			"title": "Function Type",
			"description": "Function signature with parameter and return types",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "fn"
				},
				"optionalParams": {
					"type": "array",
					"items": {
						"type": "boolean"
					}
				},
				"params": {
					"type": "array",
					"items": {
						"$ref": "#/$defs/Type"
					}
				},
				"returns": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"params",
				"returns"
			],
			"id": "FnType"
		},
		"FunctionSignature": {
			"title": "Function Signature",
			"description": "Declared function signature with purity annotation",
			"type": "object",
			"properties": {
				"name": {
					"type": "string"
				},
				"ns": {
					"type": "string"
				},
				"params": {
					"type": "array",
					"items": {
						"$ref": "#/$defs/Type"
					}
				},
				"pure": {
					"type": "boolean"
				},
				"returns": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"ns",
				"name",
				"params",
				"returns",
				"pure"
			],
			"id": "FunctionSignature"
		},
		"FutureType": {
			"title": "Future Type",
			"description": "Asynchronous value that resolves later",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "future"
				},
				"of": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"of"
			],
			"id": "FutureType"
		},
		"IfExpr": {
			"title": "If Expression",
			"description": "Conditional expression with then/else branches",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"then": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				},
				"else": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				},
				"cond": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				},
				"kind": {
					"type": "string",
					"const": "if"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"cond",
				"then",
				"else"
			],
			"id": "IfExpr"
		},
		"ImportEntry": {
			"title": "Import Entry",
			"description": "Single entry in $imports object",
			"type": "object",
			"properties": {
				"$ref": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"$ref"
			],
			"id": "ImportEntry"
		},
		"IntType": {
			"title": "Integer Type",
			"description": "Arbitrary-precision integer type",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "int"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "IntType"
		},
		"LambdaExpr": {
			"title": "Lambda Expression",
			"description": "Anonymous function with parameters and a body node",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"body": {
					"type": "string"
				},
				"kind": {
					"type": "string",
					"const": "lambda"
				},
				"params": {
					"type": "array",
					"items": {
						"anyOf": [
							{
								"type": "string"
							},
							{
								"$ref": "#/$defs/LambdaParam"
							}
						]
					}
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"params",
				"body",
				"type"
			],
			"id": "LambdaExpr"
		},
		"LambdaParam": {
			"title": "Lambda Parameter",
			"description": "Named parameter with optional type, default value, and optionality flag",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"default": {
					"$ref": "#/$defs/Expr"
				},
				"name": {
					"type": "string"
				},
				"optional": {
					"type": "boolean"
				}
			},
			"additionalProperties": false,
			"required": [
				"name"
			],
			"id": "LambdaParam"
		},
		"LambdaPat": {
			"title": "Lambda Pattern",
			"description": "Matches lambda expressions with parameter patterns and body pattern",
			"type": "object",
			"properties": {
				"body": {
					"$ref": "#/$defs/ExprPattern"
				},
				"kind": {
					"type": "string",
					"const": "lambdaPat"
				},
				"params": {
					"type": "array",
					"items": {
						"type": "string"
					}
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"params",
				"body"
			],
			"id": "LambdaPat"
		},
		"LetExpr": {
			"title": "Let Expression",
			"description": "Local binding that scopes a name to a value within a body",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"body": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				},
				"kind": {
					"type": "string",
					"const": "let"
				},
				"name": {
					"type": "string"
				},
				"value": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"name",
				"value",
				"body"
			],
			"id": "LetExpr"
		},
		"LirBlock": {
			"title": "Basic Block",
			"description": "Sequence of instructions ending with a control-flow terminator",
			"type": "object",
			"properties": {
				"id": {
					"type": "string"
				},
				"instructions": {
					"type": "array",
					"items": {
						"$ref": "#/$defs/LirInstruction"
					}
				},
				"terminator": {
					"$ref": "#/$defs/LirTerminator"
				}
			},
			"additionalProperties": false,
			"required": [
				"id",
				"instructions",
				"terminator"
			],
			"id": "LirBlock"
		},
		"LirInsAssign": {
			"title": "LIR Assign Instruction",
			"description": "Assign an expression result to a target variable",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "assign"
				},
				"target": {
					"type": "string"
				},
				"value": {
					"$ref": "#/$defs/CirExpr"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"target",
				"value"
			],
			"id": "LirInsAssign"
		},
		"LirInsAssignRef": {
			"title": "LIR Assign-Ref Instruction",
			"description": "Assign a value to a mutable reference cell",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "assignRef"
				},
				"target": {
					"type": "string"
				},
				"value": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"target",
				"value"
			],
			"id": "LirInsAssignRef"
		},
		"LirInsCall": {
			"title": "LIR Call Instruction",
			"description": "Direct function call storing result in target",
			"type": "object",
			"properties": {
				"args": {
					"type": "array",
					"items": {
						"type": "string"
					}
				},
				"callee": {
					"type": "string"
				},
				"kind": {
					"type": "string",
					"const": "call"
				},
				"target": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"target",
				"callee",
				"args"
			],
			"id": "LirInsCall"
		},
		"LirInsEffect": {
			"title": "LIR Effect Instruction",
			"description": "Side-effecting operation within a basic block",
			"type": "object",
			"properties": {
				"args": {
					"type": "array",
					"items": {
						"type": "string"
					}
				},
				"kind": {
					"type": "string",
					"const": "effect"
				},
				"op": {
					"type": "string"
				},
				"target": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"op",
				"args"
			],
			"id": "LirInsEffect"
		},
		"LirInsOp": {
			"title": "LIR Operator Instruction",
			"description": "Namespaced operator application storing result in target",
			"type": "object",
			"properties": {
				"args": {
					"type": "array",
					"items": {
						"type": "string"
					}
				},
				"kind": {
					"type": "string",
					"const": "op"
				},
				"name": {
					"type": "string"
				},
				"ns": {
					"type": "string"
				},
				"target": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"target",
				"ns",
				"name",
				"args"
			],
			"id": "LirInsOp"
		},
		"LirInsPhi": {
			"title": "LIR Phi Instruction",
			"description": "SSA phi node selecting a value based on predecessor block",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "phi"
				},
				"sources": {
					"type": "array",
					"items": {
						"type": "object",
						"properties": {
							"block": {
								"type": "string"
							},
							"id": {
								"type": "string"
							}
						},
						"additionalProperties": false,
						"required": [
							"block",
							"id"
						]
					}
				},
				"target": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"target",
				"sources"
			],
			"id": "LirInsPhi"
		},
		"LirInstruction": {
			"anyOf": [
				{
					"$ref": "#/$defs/LirInsAssign"
				},
				{
					"$ref": "#/$defs/LirInsCall"
				},
				{
					"$ref": "#/$defs/LirInsOp"
				},
				{
					"$ref": "#/$defs/LirInsPhi"
				},
				{
					"$ref": "#/$defs/LirInsEffect"
				},
				{
					"$ref": "#/$defs/LirInsAssignRef"
				}
			],
			"description": "Single instruction within a basic block",
			"id": "LirInstruction",
			"title": "LIR Instruction"
		},
		"LirTermBranch": {
			"title": "Branch Terminator",
			"description": "Conditional branch to then or else block based on a condition",
			"type": "object",
			"properties": {
				"cond": {
					"type": "string"
				},
				"else": {
					"type": "string"
				},
				"kind": {
					"type": "string",
					"const": "branch"
				},
				"then": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"cond",
				"then",
				"else"
			],
			"id": "LirTermBranch"
		},
		"LirTermExit": {
			"title": "Exit Terminator",
			"description": "Terminate program execution with an optional exit code",
			"type": "object",
			"properties": {
				"code": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"type": "number"
						}
					]
				},
				"kind": {
					"type": "string",
					"const": "exit"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "LirTermExit"
		},
		"LirTermJump": {
			"title": "Jump Terminator",
			"description": "Unconditional jump to a target block",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "jump"
				},
				"to": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"to"
			],
			"id": "LirTermJump"
		},
		"LirTermReturn": {
			"title": "Return Terminator",
			"description": "Return a value from the current function",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "return"
				},
				"value": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "LirTermReturn"
		},
		"LirTerminator": {
			"anyOf": [
				{
					"$ref": "#/$defs/LirTermJump"
				},
				{
					"$ref": "#/$defs/LirTermBranch"
				},
				{
					"$ref": "#/$defs/LirTermReturn"
				},
				{
					"$ref": "#/$defs/LirTermExit"
				}
			],
			"description": "Control-flow terminator ending a basic block",
			"id": "LirTerminator",
			"title": "LIR Terminator"
		},
		"ListOfExpr": {
			"title": "ListOf Expression",
			"description": "Construct a list from computed node references and inline expressions",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"elements": {
					"type": "array",
					"items": {
						"anyOf": [
							{
								"type": "string"
							},
							{
								"$ref": "#/$defs/Expr"
							}
						]
					}
				},
				"kind": {
					"type": "string",
					"const": "listOf"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"elements"
			],
			"id": "ListOfExpr"
		},
		"ListType": {
			"title": "List Type",
			"description": "Ordered sequence of elements",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "list"
				},
				"of": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"of"
			],
			"id": "ListType"
		},
		"LitExpr": {
			"title": "Literal Expression",
			"description": "Constant value with an explicit type annotation",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"kind": {
					"type": "string",
					"const": "lit"
				},
				"value": {}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"type",
				"value"
			],
			"id": "LitExpr"
		},
		"LitPat": {
			"title": "Literal Pattern",
			"description": "Matches literal values with optional type constraint",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "litPat"
				},
				"value": {},
				"type": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"value"
			],
			"id": "LitPat"
		},
		"MapType": {
			"title": "Map Type",
			"description": "Key-value associative container",
			"type": "object",
			"properties": {
				"key": {
					"$ref": "#/$defs/Type"
				},
				"kind": {
					"type": "string",
					"const": "map"
				},
				"value": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"key",
				"value"
			],
			"id": "MapType"
		},
		"MatchExpr": {
			"title": "Match Expression",
			"description": "Multi-way string matching that evaluates the body of the first matching case",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"default": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				},
				"cases": {
					"type": "array",
					"items": {
						"type": "object",
						"properties": {
							"body": {
								"anyOf": [
									{
										"type": "string"
									},
									{
										"$ref": "#/$defs/Expr"
									}
								]
							},
							"pattern": {
								"type": "string"
							}
						},
						"additionalProperties": false,
						"required": [
							"pattern",
							"body"
						]
					}
				},
				"kind": {
					"type": "string",
					"const": "match"
				},
				"value": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"value",
				"cases"
			],
			"id": "MatchExpr"
		},
		"MatchExprExpr": {
			"title": "Expression Match Expression",
			"description": "Structural pattern matching on expression ASTs",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"value": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				},
				"cases": {
					"type": "array",
					"items": {
						"type": "object",
						"properties": {
							"body": {
								"anyOf": [
									{
										"type": "string"
									},
									{
										"$ref": "#/$defs/Expr"
									}
								]
							},
							"pattern": {
								"$ref": "#/$defs/ExprPattern"
							}
						},
						"additionalProperties": false,
						"required": [
							"pattern",
							"body"
						]
					}
				},
				"default": {
					"anyOf": [
						{
							"type": "string"
						},
						{
							"$ref": "#/$defs/Expr"
						}
					]
				},
				"kind": {
					"type": "string",
					"const": "matchExpr"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"value",
				"cases"
			],
			"id": "MatchExprExpr"
		},
		"OpaqueType": {
			"title": "Opaque Type",
			"description": "Named opaque type whose internal structure is hidden",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "opaque"
				},
				"name": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"name"
			],
			"id": "OpaqueType"
		},
		"OptionType": {
			"title": "Option Type",
			"description": "Nullable wrapper type (Some or None)",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "option"
				},
				"of": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"of"
			],
			"id": "OptionType"
		},
		"PredicateExpr": {
			"title": "Predicate Expression",
			"description": "Type predicate that always returns true for its argument",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "predicate"
				},
				"name": {
					"type": "string"
				},
				"value": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"name",
				"value"
			],
			"id": "PredicateExpr"
		},
		"QuoteExpr": {
			"title": "Quote Expression",
			"description": "Quote an expression as data (prevents evaluation)",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"expr": {
					"$ref": "#/$defs/Expr"
				},
				"kind": {
					"type": "string",
					"const": "quote"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"expr"
			],
			"id": "QuoteExpr"
		},
		"RecordExpr": {
			"title": "Record Expression",
			"description": "Construct a map/record from string keys and computed values",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"fields": {
					"type": "array",
					"items": {
						"type": "object",
						"properties": {
							"key": {
								"type": "string"
							},
							"value": {
								"anyOf": [
									{
										"type": "string"
									},
									{
										"$ref": "#/$defs/Expr"
									}
								]
							}
						},
						"additionalProperties": false,
						"required": [
							"key",
							"value"
						]
					}
				},
				"kind": {
					"type": "string",
					"const": "record"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"fields"
			],
			"id": "RecordExpr"
		},
		"RefExpr": {
			"title": "Reference Expression",
			"description": "Reference to another node by its ID",
			"type": "object",
			"properties": {
				"id": {
					"type": "string"
				},
				"kind": {
					"type": "string",
					"const": "ref"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"id"
			],
			"id": "RefExpr"
		},
		"RefNode": {
			"title": "Node Reference",
			"description": "Node-level JSON Pointer reference for aliasing",
			"type": "object",
			"properties": {
				"$ref": {
					"type": "string"
				},
				"id": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"id",
				"$ref"
			],
			"id": "RefNode"
		},
		"RefPointerExpr": {
			"title": "JSON Pointer Reference",
			"description": "RFC 6901 JSON Pointer reference for deduplication",
			"type": "object",
			"properties": {
				"$ref": {
					"type": "string"
				},
				"kind": {
					"type": "string",
					"const": "$ref"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"$ref"
			],
			"id": "RefPointerExpr"
		},
		"RefType": {
			"title": "Reference Type",
			"description": "Mutable reference to a value",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "ref"
				},
				"of": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"of"
			],
			"id": "RefType"
		},
		"SetType": {
			"title": "Set Type",
			"description": "Unordered collection of unique elements",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "set"
				},
				"of": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"of"
			],
			"id": "SetType"
		},
		"SpliceExpr": {
			"title": "Splice Expression",
			"description": "Splice a quoted expression into code (unquote)",
			"type": "object",
			"properties": {
				"type": {
					"$ref": "#/$defs/Type"
				},
				"expr": {
					"$ref": "#/$defs/Expr"
				},
				"kind": {
					"type": "string",
					"const": "splice"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"expr"
			],
			"id": "SpliceExpr"
		},
		"StringType": {
			"title": "String Type",
			"description": "UTF-8 string type",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "StringType"
		},
		"TaskType": {
			"title": "Task Type",
			"description": "Spawnable concurrent task with a return type",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "task"
				},
				"returns": {
					"$ref": "#/$defs/Type"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"returns"
			],
			"id": "TaskType"
		},
		"Type": {
			"anyOf": [
				{
					"$ref": "#/$defs/BoolType"
				},
				{
					"$ref": "#/$defs/IntType"
				},
				{
					"$ref": "#/$defs/FloatType"
				},
				{
					"$ref": "#/$defs/StringType"
				},
				{
					"$ref": "#/$defs/VoidType"
				},
				{
					"$ref": "#/$defs/SetType"
				},
				{
					"$ref": "#/$defs/ListType"
				},
				{
					"$ref": "#/$defs/MapType"
				},
				{
					"$ref": "#/$defs/OptionType"
				},
				{
					"$ref": "#/$defs/OpaqueType"
				},
				{
					"$ref": "#/$defs/FnType"
				},
				{
					"$ref": "#/$defs/RefType"
				},
				{
					"$ref": "#/$defs/FutureType"
				},
				{
					"$ref": "#/$defs/ChannelType"
				},
				{
					"$ref": "#/$defs/TaskType"
				},
				{
					"$ref": "#/$defs/AsyncFnType"
				}
			],
			"description": "Union of all SPIRAL type annotations",
			"id": "Type",
			"title": "Type"
		},
		"VarExpr": {
			"title": "Variable Expression",
			"description": "Named variable reference (e.g., lambda parameter)",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "var"
				},
				"name": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"name"
			],
			"id": "VarExpr"
		},
		"VarPat": {
			"title": "Variable Pattern",
			"description": "Matches any expression and binds it to a variable name",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "varPat"
				},
				"name": {
					"type": "string"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind",
				"name"
			],
			"id": "VarPat"
		},
		"VoidType": {
			"title": "Void Type",
			"description": "Unit type representing no value",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "void"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "VoidType"
		},
		"WildcardPat": {
			"title": "Wildcard Pattern",
			"description": "Matches any expression without binding",
			"type": "object",
			"properties": {
				"kind": {
					"type": "string",
					"const": "_"
				}
			},
			"additionalProperties": false,
			"required": [
				"kind"
			],
			"id": "WildcardPat"
		}
	},
	"title": "SPIRAL Document",
	"description": "SPIRALDocument",
	"anyOf": [
		{
			"$ref": "#/$defs/AIRDocument"
		},
		{
			"$ref": "#/$defs/CIRDocument"
		},
		{
			"$ref": "#/$defs/EIRDocument"
		},
		{
			"$ref": "#/$defs/LIRDocument"
		}
	],
	"id": "SPIRALDocument"
}
